{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Theoretical Foundation: Derivation of Projectile Motion Equations This section derives the equations governing projectile motion from Newton's second law, formulating differential equations for two-dimensional motion under gravity and solving them. 1. Newton's Second Law and Forces Projectile motion is governed by Newton's second law, \\(\\vec{F} = m \\vec{a}\\) , with gravity as the sole force: $$ \\vec{F} = -mg \\hat{j}, \\quad \\vec{a} = -g \\hat{j}. $$ In components: $$ a_x = 0, \\quad a_y = -g. $$ 2. Differential Equations of Motion Acceleration is the second derivative of position \\(\\vec{r}(t) = (x(t), y(t))\\) : $$ \\frac{d^2 x}{dt^2} = 0, \\quad \\frac{d^2 y}{dt^2} = -g. $$ 3. Solving the Horizontal Component Integrate \\(\\frac{d^2 x}{dt^2} = 0\\) : $$ \\frac{dx}{dt} = v_x, \\quad x(t) = v_x t + x_0. $$ With \\(x_0 = 0\\) and \\(v_x = v_0 \\cos\\theta\\) : $$ x(t) = v_0 \\cos\\theta \\, t. $$ 4. Solving the Vertical Component Integrate \\(\\frac{d^2 y}{dt^2} = -g\\) : $$ \\frac{dy}{dt} = -g t + v_y, \\quad y(t) = -\\frac{1}{2} g t^2 + v_y t + y_0. $$ With \\(v_y = v_0 \\sin\\theta\\) and \\(y_0 = h\\) : $$ y(t) = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h. $$ 5. General Equations of Motion Combine both components: $$ \\vec{r}(t) = (v_0 \\cos\\theta \\, t, -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h). $$ Eliminate \\(t\\) : $$ y(x) = -\\frac{g}{2 v_0^2 \\cos^2\\theta} x^2 + \\tan\\theta \\, x + h. $$ 6. Family of Solutions and Initial Conditions The equations depend on \\(v_0\\) , \\(\\theta\\) , and \\(h\\) . For \\(h = 0\\) , solve \\(y(t) = 0\\) : $$ t = \\frac{2 v_0 \\sin\\theta}{g}. $$ The range \\(R\\) is: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g}. $$ This family of solutions illustrates the versatility of projectile motion. Analysis of the Range: Dependence on Angle of Projection This section analyzes the horizontal range of a projectile as a function of the angle of projection, leveraging the equations derived previously. We determine the time of flight, investigate trigonometric dependencies, explore parameter effects, and identify critical angles, maintaining a theoretical focus without numerical computation. 1. Expressing the Horizontal Range The horizontal range \\(R\\) is the distance traveled along the x-axis when the projectile returns to a specified height (typically \\(y = 0\\) for level ground). From the position equations: $$ x(t) = v_0 \\cos\\theta \\, t, \\quad y(t) = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h, $$ \\(R\\) is \\(x(t)\\) evaluated at the time of flight \\(t_f\\) , when \\(y(t_f) = 0\\) . Thus: $$ R = x(t_f) = v_0 \\cos\\theta \\, t_f. $$ The expression for \\(t_f\\) is derived next. 2. Determining the Time of Flight The time of flight \\(t_f\\) is the duration from launch to landing. Set \\(y(t) = 0\\) for a projectile launched from height \\(h\\) : $$ 0 = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h. $$ This is a quadratic equation in \\(t\\) : $$ -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h = 0. $$ Multiply through by \\(-2/g\\) to simplify: $$ t^2 - \\frac{2 v_0 \\sin\\theta}{g} t - \\frac{2 h}{g} = 0. $$ Solve using the quadratic formula \\(t = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\) , where \\(a = 1\\) , \\(b = -\\frac{2 v_0 \\sin\\theta}{g}\\) , \\(c = -\\frac{2 h}{g}\\) : $$ t = \\frac{\\frac{2 v_0 \\sin\\theta}{g} \\pm \\sqrt{\\left(\\frac{2 v_0 \\sin\\theta}{g}\\right)^2 - 4 \\cdot 1 \\cdot \\left(-\\frac{2 h}{g}\\right)}}{2}. $$ Simplify the discriminant: $$ \\Delta = \\left(\\frac{2 v_0 \\sin\\theta}{g}\\right)^2 + \\frac{8 h}{g} = \\frac{4 v_0^2 \\sin^2\\theta}{g^2} + \\frac{8 h}{g}. $$ Thus: $$ t = \\frac{\\frac{2 v_0 \\sin\\theta}{g} \\pm \\sqrt{\\frac{4 v_0^2 \\sin^2\\theta + 8 h g}{g^2}}}{2} = \\frac{v_0 \\sin\\theta \\pm \\sqrt{v_0^2 \\sin^2\\theta + 2 h g}}{g}. $$ For \\(h = 0\\) (level ground), this reduces to: $$ t_f = \\frac{2 v_0 \\sin\\theta}{g}, $$ selecting the positive root (time after launch). Substitute into the range: $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g}. $$ Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g}. $$ 3. Variation with Angle of Projection The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) depends on \\(\\sin 2\\theta\\) , which varies with \\(\\theta\\) : - At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) (no horizontal travel). - The term \\(\\sin 2\\theta\\) oscillates between \\(-1\\) and \\(1\\) , with a maximum of \\(1\\) when \\(2\\theta = 90^\\circ\\) (i.e., \\(\\theta = 45^\\circ\\) ). - Symmetry exists: \\(\\sin 2(90^\\circ - \\theta) = \\sin (180^\\circ - 2\\theta) = \\sin 2\\theta\\) , so \\(R(\\theta) = R(90^\\circ - \\theta)\\) (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) yield equal ranges). This trigonometric dependence indicates \\(R\\) peaks at an intermediate angle and decreases symmetrically around it. 4. Effect of Parameters Initial Velocity ( \\(v_0\\) ) : Since \\(R \\propto v_0^2\\) , doubling \\(v_0\\) quadruples \\(R\\) , amplifying the range for all angles. The shape of \\(R\\) vs. \\(\\theta\\) remains unchanged, but the amplitude scales. Gravitational Acceleration ( \\(g\\) ) : \\(R \\propto 1/g\\) , so increasing \\(g\\) (e.g., on a planet with stronger gravity) reduces \\(R\\) proportionally. The angle dependence persists, but the curve compresses vertically. Initial Height ( \\(h\\) ) : For \\(h > 0\\) , \\(t_f\\) increases (per the quadratic solution), extending \\(R\\) . The maximum range angle shifts below \\(45^\\circ\\) , as vertical flight time contributes more to horizontal distance. 5. Key Angles Maximum Range Angle : For \\(h = 0\\) , \\(R\\) is maximized when \\(\\sin 2\\theta = 1\\) , i.e., \\(\\theta = 45^\\circ\\) , balancing horizontal and vertical components optimally. Complementary Angles : Pairs like \\(30^\\circ\\) and \\(60^\\circ\\) yield identical ranges due to \\(\\sin 2\\theta\\) symmetry. Effect of Height : When \\(h \\neq 0\\) , the optimal angle decreases, derivable by maximizing the full range expression (not computed here). Practical Applications of Projectile Motion This section explores the relevance of projectile motion in real-world contexts, modifications to the idealized model, and the impact of simplifying assumptions. The equations \\(x(t) = v_0 \\cos\\theta \\, t\\) and \\(y(t) = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h\\) with range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) for \\(h = 0\\) serve as the foundation. 1. Real-World Scenarios Projectile motion is crucial in: Sports : Basketball shots, soccer kicks, and golf drives follow parabolic paths influenced by \\(\\theta\\) and \\(v_0\\) . Military : Artillery shells' trajectories depend on \\(v_0\\) and \\(\\theta\\) , with terrain and wind affecting predictions. Space Exploration : Initial rocket phases resemble projectile motion, with \\(g\\) varying with altitude. 2. Modifications for Uneven Terrain For uneven terrain, adjust the final height \\(y_f\\) : \\[ y_f = -\\frac{1}{2} g t_f^2 + v_0 \\sin\\theta \\, t_f + h. \\] Solve for \\(t_f\\) : $$ t_f = \\frac{v_0 \\sin\\theta \\pm \\sqrt{(v_0 \\sin\\theta)^2 - 2 g (h - y_f)}}{g}. $$ The range is: $$ R = v_0 \\cos\\theta \\, t_f. $$ 3. Incorporating Air Resistance Air resistance, modeled as \\(F_d = -k v\\) or \\(F_d = -c v^2\\) , modifies the equations of motion: $$ \\frac{d^2 x}{dt^2} = -\\frac{c}{m} \\dot{x}, \\quad \\frac{d^2 y}{dt^2} = -g - \\frac{c}{m} \\dot{y}. $$ These require numerical methods for solutions, reducing range and altering trajectory shape. 4. Simplifying Assumptions and Their Impact Assumptions like no drag, flat ground, constant \\(g\\) , and point mass simplify the model but limit accuracy. Real-world scenarios need adjustments for air resistance, terrain, varying \\(g\\) , and object rotation. These refinements ensure more accurate predictions beyond the idealized \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) . Conclusion The theoretical framework provides a rigorous foundation for analyzing projectile range as a function of the angle of projection, with dependencies on initial velocity \\(v_0\\) , angle \\(\\theta\\) , and initial height \\(h\\) . For \\(h = 0\\) , the range is expressed as \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) . Introducing a non-zero \\(h\\) extends flight time and shifts the optimal angle. This model applies to sports, military, and space exploration, but requires adaptations for real-world dynamics. Adjustments for uneven terrain, air resistance, and varying \\(g\\) enhance predictive accuracy. Computational simulations and visualizations clarify parametric effects and practical implications. These efforts underscore the versatility of projectile motion, providing a robust platform for theoretical and practical applications. Codes and Plots Range vs. Angle for Varying Initial Velocities import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20.0 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) # Angle array (0 to 90 degrees, in radians) theta_deg = np.linspace(0, 90, 91) # Degrees theta = np.radians(theta_deg) # Radians # Range calculation: R = (v0^2 * sin(2*theta)) / g R = (v0**2 * np.sin(2 * theta)) / g # Plotting plt.figure(figsize=(8, 6)) plt.plot(theta_deg, R, label=f'$v_0 = {v0} \\, \\mathrm{{m/s}}$', color='blue') plt.xlabel('Angle of Projection ($\\\\theta$, degrees)') plt.ylabel('Range ($R$, meters)') plt.title('Range vs. Angle of Projection ($h = 0$)') plt.grid(True) plt.legend() plt.show() Range vs. Angle with Initial Height import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20.0 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) h_values = [0, 10, 20] # Initial heights (m) # Angle array theta_deg = np.linspace(0, 90, 91) theta = np.radians(theta_deg) # Plotting plt.figure(figsize=(8, 6)) for h in h_values: # Time of flight: t = (v0*sin(theta) + sqrt((v0*sin(theta))^2 + 2gh)) / g t_f = (v0 * np.sin(theta) + np.sqrt((v0 * np.sin(theta))**2 + 2 * g * h)) / g R = v0 * np.cos(theta) * t_f plt.plot(theta_deg, R, label=f'$h = {h} \\, \\mathrm{{m}}$') plt.xlabel('Angle of Projection ($\\\\theta$, degrees)') plt.ylabel('Range ($R$, meters)') plt.title('Range vs. Angle for Different Initial Heights') plt.grid(True) plt.legend() plt.show() Projectile Motion Demonstration Earth (g = 9.81 m/s\u00b2) Moon (g = 1.62 m/s\u00b2) Jupiter (g = 24.79 m/s\u00b2) Projectile Motion Comparison import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import display, Image # Constants m = 1.0 # Mass (kg) v0 = 20.0 # Initial upward velocity (m/s) h0 = 0.0 # Initial height (m) # Gravitational accelerations (m/s^2) planets = { 'Earth': 9.81, # Earth 'Moon': 1.62, # Moon 'Jupiter': 24.79 # Jupiter } # Function to calculate position def height(t, v0, g, h0): return h0 + v0 * t - 0.5 * g * t**2 # Function to create and save animation as GIF def animate_projectile(planet, g): t_max = 2 * v0 / g t = np.linspace(0, t_max, 100) h = height(t, v0, g, h0) h = np.maximum(h, 0) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim([0, 1]) ax.set_ylim([0, 130]) # Fixed max height for comparison (Moon reaches ~123 m) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Height (m)') ax.set_title(f'Projectile Motion on {planet} (g = {g} m/s\u00b2)') ax.grid(True) x_data = np.array([0.5]) ball, = ax.plot(x_data, [h[0]], 'ro', markersize=10, label='Object (1 kg)') ax.legend() def update(frame): ball.set_data(x_data, [h[frame]]) return ball, anim = FuncAnimation(fig, update, frames=range(len(t)), interval=50, repeat=True) gif_filename = f'{planet}_projectile.gif' anim.save(gif_filename, writer='pillow', fps=20) plt.close(fig) display(Image(filename=gif_filename)) # Static comparison plot def compare_trajectories(): fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlabel('Time (s)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion Comparison: Earth, Moon, Jupiter') ax.grid(True) max_t = 2 * v0 / planets['Moon'] # Longest flight time (Moon) t = np.linspace(0, max_t, 200) for planet, g in planets.items(): h = height(t, v0, g, h0) h = np.maximum(h, 0) ax.plot(t, h, label=f'{planet} (g = {g} m/s\u00b2)') ax.set_ylim(0, 130) # Fixed scale to show Moon's max height ax.legend() plt.show() # Run animations for planet, g in planets.items(): animate_projectile(planet, g) # Show static comparison compare_trajectories() Website with different parameters ProjectileMotion Colab Colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation-derivation-of-projectile-motion-equations","text":"This section derives the equations governing projectile motion from Newton's second law, formulating differential equations for two-dimensional motion under gravity and solving them.","title":"Theoretical Foundation: Derivation of Projectile Motion Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-newtons-second-law-and-forces","text":"Projectile motion is governed by Newton's second law, \\(\\vec{F} = m \\vec{a}\\) , with gravity as the sole force: $$ \\vec{F} = -mg \\hat{j}, \\quad \\vec{a} = -g \\hat{j}. $$ In components: $$ a_x = 0, \\quad a_y = -g. $$","title":"1. Newton's Second Law and Forces"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-differential-equations-of-motion","text":"Acceleration is the second derivative of position \\(\\vec{r}(t) = (x(t), y(t))\\) : $$ \\frac{d^2 x}{dt^2} = 0, \\quad \\frac{d^2 y}{dt^2} = -g. $$","title":"2. Differential Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-solving-the-horizontal-component","text":"Integrate \\(\\frac{d^2 x}{dt^2} = 0\\) : $$ \\frac{dx}{dt} = v_x, \\quad x(t) = v_x t + x_0. $$ With \\(x_0 = 0\\) and \\(v_x = v_0 \\cos\\theta\\) : $$ x(t) = v_0 \\cos\\theta \\, t. $$","title":"3. Solving the Horizontal Component"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-solving-the-vertical-component","text":"Integrate \\(\\frac{d^2 y}{dt^2} = -g\\) : $$ \\frac{dy}{dt} = -g t + v_y, \\quad y(t) = -\\frac{1}{2} g t^2 + v_y t + y_0. $$ With \\(v_y = v_0 \\sin\\theta\\) and \\(y_0 = h\\) : $$ y(t) = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h. $$","title":"4. Solving the Vertical Component"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-general-equations-of-motion","text":"Combine both components: $$ \\vec{r}(t) = (v_0 \\cos\\theta \\, t, -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h). $$ Eliminate \\(t\\) : $$ y(x) = -\\frac{g}{2 v_0^2 \\cos^2\\theta} x^2 + \\tan\\theta \\, x + h. $$","title":"5. General Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-family-of-solutions-and-initial-conditions","text":"The equations depend on \\(v_0\\) , \\(\\theta\\) , and \\(h\\) . For \\(h = 0\\) , solve \\(y(t) = 0\\) : $$ t = \\frac{2 v_0 \\sin\\theta}{g}. $$ The range \\(R\\) is: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g}. $$ This family of solutions illustrates the versatility of projectile motion.","title":"6. Family of Solutions and Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range-dependence-on-angle-of-projection","text":"This section analyzes the horizontal range of a projectile as a function of the angle of projection, leveraging the equations derived previously. We determine the time of flight, investigate trigonometric dependencies, explore parameter effects, and identify critical angles, maintaining a theoretical focus without numerical computation.","title":"Analysis of the Range: Dependence on Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-expressing-the-horizontal-range","text":"The horizontal range \\(R\\) is the distance traveled along the x-axis when the projectile returns to a specified height (typically \\(y = 0\\) for level ground). From the position equations: $$ x(t) = v_0 \\cos\\theta \\, t, \\quad y(t) = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h, $$ \\(R\\) is \\(x(t)\\) evaluated at the time of flight \\(t_f\\) , when \\(y(t_f) = 0\\) . Thus: $$ R = x(t_f) = v_0 \\cos\\theta \\, t_f. $$ The expression for \\(t_f\\) is derived next.","title":"1. Expressing the Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-determining-the-time-of-flight","text":"The time of flight \\(t_f\\) is the duration from launch to landing. Set \\(y(t) = 0\\) for a projectile launched from height \\(h\\) : $$ 0 = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h. $$ This is a quadratic equation in \\(t\\) : $$ -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h = 0. $$ Multiply through by \\(-2/g\\) to simplify: $$ t^2 - \\frac{2 v_0 \\sin\\theta}{g} t - \\frac{2 h}{g} = 0. $$ Solve using the quadratic formula \\(t = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\) , where \\(a = 1\\) , \\(b = -\\frac{2 v_0 \\sin\\theta}{g}\\) , \\(c = -\\frac{2 h}{g}\\) : $$ t = \\frac{\\frac{2 v_0 \\sin\\theta}{g} \\pm \\sqrt{\\left(\\frac{2 v_0 \\sin\\theta}{g}\\right)^2 - 4 \\cdot 1 \\cdot \\left(-\\frac{2 h}{g}\\right)}}{2}. $$ Simplify the discriminant: $$ \\Delta = \\left(\\frac{2 v_0 \\sin\\theta}{g}\\right)^2 + \\frac{8 h}{g} = \\frac{4 v_0^2 \\sin^2\\theta}{g^2} + \\frac{8 h}{g}. $$ Thus: $$ t = \\frac{\\frac{2 v_0 \\sin\\theta}{g} \\pm \\sqrt{\\frac{4 v_0^2 \\sin^2\\theta + 8 h g}{g^2}}}{2} = \\frac{v_0 \\sin\\theta \\pm \\sqrt{v_0^2 \\sin^2\\theta + 2 h g}}{g}. $$ For \\(h = 0\\) (level ground), this reduces to: $$ t_f = \\frac{2 v_0 \\sin\\theta}{g}, $$ selecting the positive root (time after launch). Substitute into the range: $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g}. $$ Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g}. $$","title":"2. Determining the Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-variation-with-angle-of-projection","text":"The range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) depends on \\(\\sin 2\\theta\\) , which varies with \\(\\theta\\) : - At \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) , \\(\\sin 2\\theta = 0\\) , so \\(R = 0\\) (no horizontal travel). - The term \\(\\sin 2\\theta\\) oscillates between \\(-1\\) and \\(1\\) , with a maximum of \\(1\\) when \\(2\\theta = 90^\\circ\\) (i.e., \\(\\theta = 45^\\circ\\) ). - Symmetry exists: \\(\\sin 2(90^\\circ - \\theta) = \\sin (180^\\circ - 2\\theta) = \\sin 2\\theta\\) , so \\(R(\\theta) = R(90^\\circ - \\theta)\\) (e.g., \\(30^\\circ\\) and \\(60^\\circ\\) yield equal ranges). This trigonometric dependence indicates \\(R\\) peaks at an intermediate angle and decreases symmetrically around it.","title":"3. Variation with Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-effect-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : Since \\(R \\propto v_0^2\\) , doubling \\(v_0\\) quadruples \\(R\\) , amplifying the range for all angles. The shape of \\(R\\) vs. \\(\\theta\\) remains unchanged, but the amplitude scales. Gravitational Acceleration ( \\(g\\) ) : \\(R \\propto 1/g\\) , so increasing \\(g\\) (e.g., on a planet with stronger gravity) reduces \\(R\\) proportionally. The angle dependence persists, but the curve compresses vertically. Initial Height ( \\(h\\) ) : For \\(h > 0\\) , \\(t_f\\) increases (per the quadratic solution), extending \\(R\\) . The maximum range angle shifts below \\(45^\\circ\\) , as vertical flight time contributes more to horizontal distance.","title":"4. Effect of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-key-angles","text":"Maximum Range Angle : For \\(h = 0\\) , \\(R\\) is maximized when \\(\\sin 2\\theta = 1\\) , i.e., \\(\\theta = 45^\\circ\\) , balancing horizontal and vertical components optimally. Complementary Angles : Pairs like \\(30^\\circ\\) and \\(60^\\circ\\) yield identical ranges due to \\(\\sin 2\\theta\\) symmetry. Effect of Height : When \\(h \\neq 0\\) , the optimal angle decreases, derivable by maximizing the full range expression (not computed here).","title":"5. Key Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"This section explores the relevance of projectile motion in real-world contexts, modifications to the idealized model, and the impact of simplifying assumptions. The equations \\(x(t) = v_0 \\cos\\theta \\, t\\) and \\(y(t) = -\\frac{1}{2} g t^2 + v_0 \\sin\\theta \\, t + h\\) with range \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) for \\(h = 0\\) serve as the foundation.","title":"Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-real-world-scenarios","text":"Projectile motion is crucial in: Sports : Basketball shots, soccer kicks, and golf drives follow parabolic paths influenced by \\(\\theta\\) and \\(v_0\\) . Military : Artillery shells' trajectories depend on \\(v_0\\) and \\(\\theta\\) , with terrain and wind affecting predictions. Space Exploration : Initial rocket phases resemble projectile motion, with \\(g\\) varying with altitude.","title":"1. Real-World Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-modifications-for-uneven-terrain","text":"For uneven terrain, adjust the final height \\(y_f\\) : \\[ y_f = -\\frac{1}{2} g t_f^2 + v_0 \\sin\\theta \\, t_f + h. \\] Solve for \\(t_f\\) : $$ t_f = \\frac{v_0 \\sin\\theta \\pm \\sqrt{(v_0 \\sin\\theta)^2 - 2 g (h - y_f)}}{g}. $$ The range is: $$ R = v_0 \\cos\\theta \\, t_f. $$","title":"2. Modifications for Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-incorporating-air-resistance","text":"Air resistance, modeled as \\(F_d = -k v\\) or \\(F_d = -c v^2\\) , modifies the equations of motion: $$ \\frac{d^2 x}{dt^2} = -\\frac{c}{m} \\dot{x}, \\quad \\frac{d^2 y}{dt^2} = -g - \\frac{c}{m} \\dot{y}. $$ These require numerical methods for solutions, reducing range and altering trajectory shape.","title":"3. Incorporating Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-simplifying-assumptions-and-their-impact","text":"Assumptions like no drag, flat ground, constant \\(g\\) , and point mass simplify the model but limit accuracy. Real-world scenarios need adjustments for air resistance, terrain, varying \\(g\\) , and object rotation. These refinements ensure more accurate predictions beyond the idealized \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) .","title":"4. Simplifying Assumptions and Their Impact"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The theoretical framework provides a rigorous foundation for analyzing projectile range as a function of the angle of projection, with dependencies on initial velocity \\(v_0\\) , angle \\(\\theta\\) , and initial height \\(h\\) . For \\(h = 0\\) , the range is expressed as \\(R = \\frac{v_0^2 \\sin 2\\theta}{g}\\) . Introducing a non-zero \\(h\\) extends flight time and shifts the optimal angle. This model applies to sports, military, and space exploration, but requires adaptations for real-world dynamics. Adjustments for uneven terrain, air resistance, and varying \\(g\\) enhance predictive accuracy. Computational simulations and visualizations clarify parametric effects and practical implications. These efforts underscore the versatility of projectile motion, providing a robust platform for theoretical and practical applications.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#codes-and-plots","text":"","title":"Codes and Plots"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-for-varying-initial-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20.0 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) # Angle array (0 to 90 degrees, in radians) theta_deg = np.linspace(0, 90, 91) # Degrees theta = np.radians(theta_deg) # Radians # Range calculation: R = (v0^2 * sin(2*theta)) / g R = (v0**2 * np.sin(2 * theta)) / g # Plotting plt.figure(figsize=(8, 6)) plt.plot(theta_deg, R, label=f'$v_0 = {v0} \\, \\mathrm{{m/s}}$', color='blue') plt.xlabel('Angle of Projection ($\\\\theta$, degrees)') plt.ylabel('Range ($R$, meters)') plt.title('Range vs. Angle of Projection ($h = 0$)') plt.grid(True) plt.legend() plt.show()","title":"Range vs. Angle for Varying Initial Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-with-initial-height","text":"import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20.0 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) h_values = [0, 10, 20] # Initial heights (m) # Angle array theta_deg = np.linspace(0, 90, 91) theta = np.radians(theta_deg) # Plotting plt.figure(figsize=(8, 6)) for h in h_values: # Time of flight: t = (v0*sin(theta) + sqrt((v0*sin(theta))^2 + 2gh)) / g t_f = (v0 * np.sin(theta) + np.sqrt((v0 * np.sin(theta))**2 + 2 * g * h)) / g R = v0 * np.cos(theta) * t_f plt.plot(theta_deg, R, label=f'$h = {h} \\, \\mathrm{{m}}$') plt.xlabel('Angle of Projection ($\\\\theta$, degrees)') plt.ylabel('Range ($R$, meters)') plt.title('Range vs. Angle for Different Initial Heights') plt.grid(True) plt.legend() plt.show()","title":"Range vs. Angle with Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-demonstration","text":"","title":"Projectile Motion Demonstration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#earth-g-981-ms2","text":"","title":"Earth (g = 9.81 m/s\u00b2)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#moon-g-162-ms2","text":"","title":"Moon (g = 1.62 m/s\u00b2)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#jupiter-g-2479-ms2","text":"","title":"Jupiter (g = 24.79 m/s\u00b2)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-comparison","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import display, Image # Constants m = 1.0 # Mass (kg) v0 = 20.0 # Initial upward velocity (m/s) h0 = 0.0 # Initial height (m) # Gravitational accelerations (m/s^2) planets = { 'Earth': 9.81, # Earth 'Moon': 1.62, # Moon 'Jupiter': 24.79 # Jupiter } # Function to calculate position def height(t, v0, g, h0): return h0 + v0 * t - 0.5 * g * t**2 # Function to create and save animation as GIF def animate_projectile(planet, g): t_max = 2 * v0 / g t = np.linspace(0, t_max, 100) h = height(t, v0, g, h0) h = np.maximum(h, 0) fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim([0, 1]) ax.set_ylim([0, 130]) # Fixed max height for comparison (Moon reaches ~123 m) ax.set_xlabel('Horizontal Distance (m)') ax.set_ylabel('Height (m)') ax.set_title(f'Projectile Motion on {planet} (g = {g} m/s\u00b2)') ax.grid(True) x_data = np.array([0.5]) ball, = ax.plot(x_data, [h[0]], 'ro', markersize=10, label='Object (1 kg)') ax.legend() def update(frame): ball.set_data(x_data, [h[frame]]) return ball, anim = FuncAnimation(fig, update, frames=range(len(t)), interval=50, repeat=True) gif_filename = f'{planet}_projectile.gif' anim.save(gif_filename, writer='pillow', fps=20) plt.close(fig) display(Image(filename=gif_filename)) # Static comparison plot def compare_trajectories(): fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlabel('Time (s)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion Comparison: Earth, Moon, Jupiter') ax.grid(True) max_t = 2 * v0 / planets['Moon'] # Longest flight time (Moon) t = np.linspace(0, max_t, 200) for planet, g in planets.items(): h = height(t, v0, g, h0) h = np.maximum(h, 0) ax.plot(t, h, label=f'{planet} (g = {g} m/s\u00b2)') ax.set_ylim(0, 130) # Fixed scale to show Moon's max height ax.legend() plt.show() # Run animations for planet, g in planets.items(): animate_projectile(planet, g) # Show static comparison compare_trajectories()","title":"Projectile Motion Comparison"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#website-with-different-parameters","text":"ProjectileMotion","title":"Website with different parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Theoretical Foundation of the Forced Damped Pendulum The forced damped pendulum combines damping, gravitational forces, and external periodic forcing. This section derives the governing differential equation, approximates solutions for small-angle oscillations, and analyzes resonance conditions. 1. Governing Differential Equation For a pendulum of length \\(l\\) and mass \\(m\\) , with gravitational acceleration \\(g\\) , damping coefficient \\(b\\) , and external force amplitude \\(F_0\\) , the angular displacement \\(\\theta(t)\\) follows: \\[ \\frac{d^2 \\theta}{dt^2} + \\frac{b}{m l} \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = \\frac{F_0}{m l} \\cos(\\omega t). \\] Defining \\(\\omega_0 = \\sqrt{g/l}\\) and \\(\\gamma = b/(2m l)\\) , we get: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(f = F_0/(m l)\\) . 2. Small-Angle Approximation For small angles, \\(\\sin\\theta \\approx \\theta\\) , simplifying to: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = f \\cos(\\omega t). \\] The general solution is: \\[ \\theta(t) = e^{-\\gamma t} (A \\cos(\\omega_d t) + B \\sin(\\omega_d t)) + R \\cos(\\omega t - \\phi), \\] with \\(\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\) , \\(R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}\\) , and \\(\\tan\\phi = \\frac{2\\gamma \\omega}{\\omega_0^2 - \\omega^2}\\) . 3. Resonance Conditions Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing \\(R\\) . For weak damping ( \\(\\gamma \\ll \\omega_0\\) ), the resonant frequency is: \\[ \\omega_r \\approx \\sqrt{\\omega_0^2 - 2\\gamma^2}. \\] The quality factor \\(Q = \\omega_0 / (2\\gamma)\\) indicates resonance sharpness. Nonlinear cases ( \\(\\sin\\theta \\neq \\theta\\) ) can lead to complex behaviors beyond small-angle approximations. Analysis of System Dynamics for the Forced Damped Pendulum This section explores how damping, driving amplitude, and frequency affect the pendulum\u2019s motion, transitioning from regular to chaotic behavior. 1. Influence of the Damping Coefficient The damping coefficient \\(b\\) introduces energy dissipation: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(\\gamma = b/(2m l)\\) , \\(\\omega_0 = \\sqrt{g/l}\\) , and \\(f = F_0/(m l)\\) . For small angles: \\[ \\theta_h(t) = e^{-\\gamma t} (A \\cos(\\omega_d t) + B \\sin(\\omega_d t)), \\] with \\(\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\) . Higher \\(\\gamma\\) reduces the steady-state amplitude \\(R\\) : \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}. \\] Increasing \\(b\\) suppresses large oscillations and stabilizes the system. 2. Impact of Driving Amplitude The driving amplitude \\(f\\) determines energy input: \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}. \\] For small \\(f\\) , the response is periodic. Large \\(f\\) can lead to rotational or chaotic motion, overcoming the potential barrier at \\(\\theta = \\pi\\) . 3. Effect of Driving Frequency The driving frequency \\(\\omega\\) affects the system\u2019s response: \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}. \\] Near resonance ( \\(\\omega \\approx \\omega_0\\) ), amplitude peaks. For \\(\\omega \\ll \\omega_0\\) , the response is adiabatic; for \\(\\omega \\gg \\omega_0\\) , it diminishes. Varying \\(\\omega\\) can induce subharmonic or quasiperiodic motion. 4. Transition from Regular to Chaotic Motion Regular motion forms predictable trajectories in phase space. Chaos emerges with aperiodic trajectories and sensitivity to initial conditions. The Lyapunov exponent \\(\\lambda > 0\\) indicates chaos: \\[ \\frac{d^2 \\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\sin\\theta = A \\cos(\\omega t), \\] where \\(\\beta = 2\\gamma/\\omega_0\\) and \\(A = f/\\omega_0^2\\) . Chaos occurs for \\(A > A_c\\) (e.g., \\(A_c \\approx 1.1\\) for \\(\\beta = 0.5\\) , \\(\\omega = 0.67\\omega_0\\) ). 5. Physical Interpretation of Regular vs. Chaotic Motion Regular motion shows discrete peaks in the power spectrum, indicating predictable oscillations. Chaotic motion has a continuous spectrum, reflecting erratic swings and sensitivity to perturbations, common in complex systems. Practical Applications of the Forced Damped Pendulum Model The forced damped pendulum serves as a fundamental model for oscillatory systems under external influence, with applications spanning engineering, physics, and technology. This section identifies key real-world examples\u2014energy harvesting devices, suspension bridges, and oscillating circuits\u2014and elucidates how insights from the model can be applied, leveraging its dynamics governed by: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(\\gamma = b/(2m l)\\) , \\(\\omega_0 = \\sqrt{g/l}\\) , and \\(f = F_0/(m l)\\) represent damping, natural frequency, and forcing amplitude, respectively. 1. Real-World Examples Energy Harvesting Devices Energy harvesting devices convert ambient mechanical vibrations into electrical energy, often using piezoelectric or electromagnetic oscillators. These systems can be modeled as forced damped pendulums when subjected to periodic environmental forces (e.g., wind or machinery vibrations). The pendulum\u2019s response, particularly near resonance, is critical: \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}, \\] where \\(R\\) is the steady-state amplitude for small angles ( \\(\\sin\\theta \\approx \\theta\\) ). Devices like vibration-powered sensors exemplify this, with \\(\\omega\\) matching ambient frequencies. Suspension Bridges Suspension bridges experience wind or traffic-induced oscillations, resembling a forced damped pendulum when cables or decks sway. The nonlinear term \\(\\omega_0^2 \\sin\\theta\\) captures large-amplitude effects, such as those observed in the Tacoma Narrows Bridge collapse. The equation\u2019s forcing term \\(f \\cos(\\omega t)\\) models periodic wind gusts, while damping \\(\\gamma\\) reflects structural energy dissipation. Oscillating Circuits In electrical engineering, driven RLC circuits (resistor-inductor-capacitor) are analogous to the forced damped pendulum. The circuit\u2019s differential equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_0 \\cos(\\omega t), \\] mirrors the pendulum\u2019s, with charge \\(q\\) akin to \\(\\theta\\) , inductance \\(L\\) to mass, resistance \\(R\\) to damping \\(b\\) , and capacitance \\(1/C\\) to \\(\\omega_0^2\\) . Applications include radio tuners and signal filters, where external voltage \\(V_0 \\cos(\\omega t)\\) drives the system. 2. Application of Model Insights Energy Harvesting Devices The model\u2019s resonance behavior maximizes energy transfer when the driving frequency \\(\\omega\\) aligns with \\(\\omega_0\\) , adjusted for damping: \\[ \\omega_r \\approx \\sqrt{\\omega_0^2 - 2\\gamma^2}. \\] Tuning \\(\\omega_0\\) (via pendulum length or mass) to match environmental frequencies enhances power output, calculated as \\(P = \\frac{1}{2} b (\\dot{\\theta})^2\\) in the mechanical domain, then converted electrically. Nonlinear effects ( \\(\\sin\\theta\\) ) inform designs for large-amplitude vibrations, preventing chaotic inefficiencies. Suspension Bridges Insights into resonance and damping guide bridge design. Excessive amplitude at \\(\\omega \\approx \\omega_0\\) risks structural failure, as \\(R\\) grows inversely with \\(\\gamma\\) . Engineers increase \\(\\gamma\\) (e.g., via dampers) to reduce \\(Q = \\omega_0/(2\\gamma)\\) , the quality factor, mitigating oscillations. The nonlinear transition to chaos warns of unpredictable large swings under strong forcing \\(f\\) , prompting aerodynamic adjustments or cable reinforcements. Oscillating Circuits The steady-state response \\(R\\) and phase \\(\\phi\\) : \\[ R = \\frac{V_0 / L}{\\sqrt{\\left(\\frac{1}{LC} - \\omega^2\\right)^2 + \\left(\\frac{R}{L} \\omega\\right)^2}}, \\quad \\tan\\phi = \\frac{R \\omega}{\\frac{1}{LC} - \\omega^2}, \\] inform circuit tuning. Resonance at \\(\\omega = 1/\\sqrt{LC}\\) amplifies signals in radios, while damping \\(R/L\\) controls bandwidth. Nonlinear analogs (e.g., with varactors) leverage chaotic dynamics for secure communication or signal processing, drawing from the pendulum\u2019s sensitivity to parameters. Conclusion The forced damped pendulum encapsulates a rich spectrum of physical behaviors, bridging theoretical nonlinear dynamics with practical engineering applications. The governing equation: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(\\gamma = b/(2m l)\\) , \\(\\omega_0 = \\sqrt{g/l}\\) , and \\(f = F_0/(m l)\\) , provides a foundation for understanding oscillatory systems under damping and external forcing. In the small-angle regime ( \\(\\sin\\theta \\approx \\theta\\) ), the solution: \\[ \\theta(t) = e^{-\\gamma t} (A \\cos(\\omega_d t) + B \\sin(\\omega_d t)) + R \\cos(\\omega t - \\phi), \\] with \\(R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}\\) , reveals resonance near \\(\\omega_r \\approx \\sqrt{\\omega_0^2 - 2\\gamma^2}\\) , offering predictable energy amplification critical for applications like energy harvesting and circuit tuning. Analysis of system dynamics highlights the roles of damping \\(\\gamma\\) , driving amplitude \\(f\\) , and frequency \\(\\omega\\) . Higher \\(\\gamma\\) stabilizes motion by reducing \\(R\\) , while large \\(f\\) and specific \\(\\omega/\\omega_0\\) ratios can trigger transitions from regular, periodic trajectories to chaotic, aperiodic ones, marked by a positive Lyapunov exponent \\(\\lambda > 0\\) . This duality\u2014regular motion\u2019s predictability versus chaos\u2019s sensitivity\u2014underscores the system\u2019s complexity. Practically, the model informs energy harvesting by optimizing \\(\\omega_0\\) for resonance, enhances suspension bridge stability by tuning \\(\\gamma\\) to mitigate \\(Q = \\omega_0/(2\\gamma)\\) , and guides oscillating circuits via analogies to RLC dynamics, where \\(R = \\frac{V_0 / L}{\\sqrt{\\left(\\frac{1}{LC} - \\omega^2\\right)^2 + \\left(\\frac{R}{L} \\omega\\right)^2}}\\) . Nonlinear insights further address large-amplitude effects and chaotic potential, from preventing bridge collapse to enabling advanced signal processing. In sum, the forced damped pendulum exemplifies how fundamental physics principles\u2014linear resonance, nonlinear transitions, and parameter interplay\u2014translate into real-world solutions, advancing both theoretical understanding and technological innovation. Website with pendulum simulations Pendulum Simulator Basic Simulation and Motion Plot import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the pendulum ODE def pendulum_deriv(state, t, gamma, omega0_sq, f, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega0_sq * np.sin(theta) + f * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) omega0_sq = g / l # natural frequency squared t = np.linspace(0, 50, 10000) # time array # Simulation function def simulate_pendulum(gamma, f, omega, theta0=0.2, theta_dot0=0.0): state0 = [theta0, theta_dot0] sol = odeint(pendulum_deriv, state0, t, args=(gamma, omega0_sq, f, omega)) return sol[:, 0], sol[:, 1] # theta, theta_dot # Example cases plt.figure(figsize=(10, 6)) # Case 1: Low damping, near resonance theta1, theta_dot1 = simulate_pendulum(gamma=0.1, f=0.5, omega=3.0) plt.subplot(2, 1, 1) plt.plot(t, theta1) plt.title(\"Motion: \u03b3=0.1, f=0.5, \u03c9=3.0 (Near Resonance)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") # Case 2: High amplitude, chaotic theta2, theta_dot2 = simulate_pendulum(gamma=0.1, f=1.2, omega=2.0) plt.subplot(2, 1, 2) plt.plot(t, theta2) plt.title(\"Motion: \u03b3=0.1, f=1.2, \u03c9=2.0 (Chaotic)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") plt.tight_layout() plt.show() Phase Portrait Generation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the pendulum ODE def pendulum_deriv(state, t, gamma, omega0_sq, f, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega0_sq * np.sin(theta) + f * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.81 l = 1.0 omega0_sq = g / l t = np.linspace(0, 50, 10000) # Simulation function def simulate_pendulum(gamma, f, omega, theta0=0.2, theta_dot0=0.0): state0 = [theta0, theta_dot0] sol = odeint(pendulum_deriv, state0, t, args=(gamma, omega0_sq, f, omega)) return sol[:, 0], sol[:, 1] # Plot phase portraits plt.figure(figsize=(10, 6)) # Case 1: Low damping, near resonance theta1, theta_dot1 = simulate_pendulum(gamma=0.1, f=0.5, omega=3.0) plt.subplot(1, 2, 1) plt.plot(theta1, theta_dot1, lw=0.5) plt.title(\"Phase Portrait: \u03b3=0.1, f=0.5, \u03c9=3.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Case 2: High amplitude, chaotic theta2, theta_dot2 = simulate_pendulum(gamma=0.1, f=1.2, omega=2.0) plt.subplot(1, 2, 2) plt.plot(theta2, theta_dot2, lw=0.5) plt.title(\"Phase Portrait: \u03b3=0.1, f=1.2, \u03c9=2.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show() Poincar\u00e9 Section Generation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the pendulum ODE def pendulum_deriv(state, t, gamma, omega0_sq, f, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega0_sq * np.sin(theta) + f * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.81 l = 1.0 omega0_sq = g / l t = np.linspace(0, 50, 10000) # Simulation function def simulate_pendulum(gamma, f, omega, theta0=0.2, theta_dot0=0.0): state0 = [theta0, theta_dot0] sol = odeint(pendulum_deriv, state0, t, args=(gamma, omega0_sq, f, omega)) return sol[:, 0], sol[:, 1] # Poincar\u00e9 section function def poincare_section(theta, theta_dot, t, omega): period = 2 * np.pi / omega indices = np.where(np.abs(t % period) < 0.01)[0] return theta[indices], theta_dot[indices] # Plot Poincar\u00e9 sections plt.figure(figsize=(10, 6)) # Case 1: Low damping, near resonance theta1, theta_dot1 = simulate_pendulum(gamma=0.1, f=0.5, omega=3.0) p_theta1, p_theta_dot1 = poincare_section(theta1, theta_dot1, t, 3.0) plt.subplot(1, 2, 1) plt.scatter(p_theta1, p_theta_dot1, s=1) plt.title(\"Poincar\u00e9: \u03b3=0.1, f=0.5, \u03c9=3.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Case 2: High amplitude, chaotic theta2, theta_dot2 = simulate_pendulum(gamma=0.1, f=1.2, omega=2.0) p_theta2, p_theta_dot2 = poincare_section(theta2, theta_dot2, t, 2.0) plt.subplot(1, 2, 2) plt.scatter(p_theta2, p_theta_dot2, s=1) plt.title(\"Poincar\u00e9: \u03b3=0.1, f=1.2, \u03c9=2.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show() Bifurcation Diagram Generation import numpy as np import matplotlib.pyplot as plt def logistic_map(r, x): return r * x * (1 - x) def bifurcation_diagram(r_min=2.5, r_max=4.0, num_r=10000, num_iter=1000, num_last=100): r_values = np.linspace(r_min, r_max, num_r) x = 0.5 * np.ones(num_r) plt.figure(figsize=(10, 6), dpi=100) for _ in range(num_iter): x = logistic_map(r_values, x) if _ >= (num_iter - num_last): plt.plot(r_values, x, ',k', alpha=0.25) plt.xlim(r_min, r_max) plt.ylim(0, 1) plt.xlabel(\"r\") plt.ylabel(\"x\") plt.title(\"Bifurcation Diagram of the Logistic Map\") plt.show() # Run the bifurcation diagram function bifurcation_diagram() Colab Colab","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation-of-the-forced-damped-pendulum","text":"The forced damped pendulum combines damping, gravitational forces, and external periodic forcing. This section derives the governing differential equation, approximates solutions for small-angle oscillations, and analyzes resonance conditions.","title":"Theoretical Foundation of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-governing-differential-equation","text":"For a pendulum of length \\(l\\) and mass \\(m\\) , with gravitational acceleration \\(g\\) , damping coefficient \\(b\\) , and external force amplitude \\(F_0\\) , the angular displacement \\(\\theta(t)\\) follows: \\[ \\frac{d^2 \\theta}{dt^2} + \\frac{b}{m l} \\frac{d\\theta}{dt} + \\frac{g}{l} \\sin\\theta = \\frac{F_0}{m l} \\cos(\\omega t). \\] Defining \\(\\omega_0 = \\sqrt{g/l}\\) and \\(\\gamma = b/(2m l)\\) , we get: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(f = F_0/(m l)\\) .","title":"1. Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-small-angle-approximation","text":"For small angles, \\(\\sin\\theta \\approx \\theta\\) , simplifying to: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = f \\cos(\\omega t). \\] The general solution is: \\[ \\theta(t) = e^{-\\gamma t} (A \\cos(\\omega_d t) + B \\sin(\\omega_d t)) + R \\cos(\\omega t - \\phi), \\] with \\(\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\) , \\(R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}\\) , and \\(\\tan\\phi = \\frac{2\\gamma \\omega}{\\omega_0^2 - \\omega^2}\\) .","title":"2. Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-resonance-conditions","text":"Resonance occurs when \\(\\omega \\approx \\omega_0\\) , maximizing \\(R\\) . For weak damping ( \\(\\gamma \\ll \\omega_0\\) ), the resonant frequency is: \\[ \\omega_r \\approx \\sqrt{\\omega_0^2 - 2\\gamma^2}. \\] The quality factor \\(Q = \\omega_0 / (2\\gamma)\\) indicates resonance sharpness. Nonlinear cases ( \\(\\sin\\theta \\neq \\theta\\) ) can lead to complex behaviors beyond small-angle approximations.","title":"3. Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-system-dynamics-for-the-forced-damped-pendulum","text":"This section explores how damping, driving amplitude, and frequency affect the pendulum\u2019s motion, transitioning from regular to chaotic behavior.","title":"Analysis of System Dynamics for the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-influence-of-the-damping-coefficient","text":"The damping coefficient \\(b\\) introduces energy dissipation: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(\\gamma = b/(2m l)\\) , \\(\\omega_0 = \\sqrt{g/l}\\) , and \\(f = F_0/(m l)\\) . For small angles: \\[ \\theta_h(t) = e^{-\\gamma t} (A \\cos(\\omega_d t) + B \\sin(\\omega_d t)), \\] with \\(\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\) . Higher \\(\\gamma\\) reduces the steady-state amplitude \\(R\\) : \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}. \\] Increasing \\(b\\) suppresses large oscillations and stabilizes the system.","title":"1. Influence of the Damping Coefficient"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-impact-of-driving-amplitude","text":"The driving amplitude \\(f\\) determines energy input: \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}. \\] For small \\(f\\) , the response is periodic. Large \\(f\\) can lead to rotational or chaotic motion, overcoming the potential barrier at \\(\\theta = \\pi\\) .","title":"2. Impact of Driving Amplitude"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-effect-of-driving-frequency","text":"The driving frequency \\(\\omega\\) affects the system\u2019s response: \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}. \\] Near resonance ( \\(\\omega \\approx \\omega_0\\) ), amplitude peaks. For \\(\\omega \\ll \\omega_0\\) , the response is adiabatic; for \\(\\omega \\gg \\omega_0\\) , it diminishes. Varying \\(\\omega\\) can induce subharmonic or quasiperiodic motion.","title":"3. Effect of Driving Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-transition-from-regular-to-chaotic-motion","text":"Regular motion forms predictable trajectories in phase space. Chaos emerges with aperiodic trajectories and sensitivity to initial conditions. The Lyapunov exponent \\(\\lambda > 0\\) indicates chaos: \\[ \\frac{d^2 \\theta}{dt^2} + \\beta \\frac{d\\theta}{dt} + \\sin\\theta = A \\cos(\\omega t), \\] where \\(\\beta = 2\\gamma/\\omega_0\\) and \\(A = f/\\omega_0^2\\) . Chaos occurs for \\(A > A_c\\) (e.g., \\(A_c \\approx 1.1\\) for \\(\\beta = 0.5\\) , \\(\\omega = 0.67\\omega_0\\) ).","title":"4. Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-physical-interpretation-of-regular-vs-chaotic-motion","text":"Regular motion shows discrete peaks in the power spectrum, indicating predictable oscillations. Chaotic motion has a continuous spectrum, reflecting erratic swings and sensitivity to perturbations, common in complex systems.","title":"5. Physical Interpretation of Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications-of-the-forced-damped-pendulum-model","text":"The forced damped pendulum serves as a fundamental model for oscillatory systems under external influence, with applications spanning engineering, physics, and technology. This section identifies key real-world examples\u2014energy harvesting devices, suspension bridges, and oscillating circuits\u2014and elucidates how insights from the model can be applied, leveraging its dynamics governed by: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(\\gamma = b/(2m l)\\) , \\(\\omega_0 = \\sqrt{g/l}\\) , and \\(f = F_0/(m l)\\) represent damping, natural frequency, and forcing amplitude, respectively.","title":"Practical Applications of the Forced Damped Pendulum Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-real-world-examples","text":"","title":"1. Real-World Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting-devices","text":"Energy harvesting devices convert ambient mechanical vibrations into electrical energy, often using piezoelectric or electromagnetic oscillators. These systems can be modeled as forced damped pendulums when subjected to periodic environmental forces (e.g., wind or machinery vibrations). The pendulum\u2019s response, particularly near resonance, is critical: \\[ R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}, \\] where \\(R\\) is the steady-state amplitude for small angles ( \\(\\sin\\theta \\approx \\theta\\) ). Devices like vibration-powered sensors exemplify this, with \\(\\omega\\) matching ambient frequencies.","title":"Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges","text":"Suspension bridges experience wind or traffic-induced oscillations, resembling a forced damped pendulum when cables or decks sway. The nonlinear term \\(\\omega_0^2 \\sin\\theta\\) captures large-amplitude effects, such as those observed in the Tacoma Narrows Bridge collapse. The equation\u2019s forcing term \\(f \\cos(\\omega t)\\) models periodic wind gusts, while damping \\(\\gamma\\) reflects structural energy dissipation.","title":"Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-circuits","text":"In electrical engineering, driven RLC circuits (resistor-inductor-capacitor) are analogous to the forced damped pendulum. The circuit\u2019s differential equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_0 \\cos(\\omega t), \\] mirrors the pendulum\u2019s, with charge \\(q\\) akin to \\(\\theta\\) , inductance \\(L\\) to mass, resistance \\(R\\) to damping \\(b\\) , and capacitance \\(1/C\\) to \\(\\omega_0^2\\) . Applications include radio tuners and signal filters, where external voltage \\(V_0 \\cos(\\omega t)\\) drives the system.","title":"Oscillating Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-application-of-model-insights","text":"","title":"2. Application of Model Insights"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting-devices_1","text":"The model\u2019s resonance behavior maximizes energy transfer when the driving frequency \\(\\omega\\) aligns with \\(\\omega_0\\) , adjusted for damping: \\[ \\omega_r \\approx \\sqrt{\\omega_0^2 - 2\\gamma^2}. \\] Tuning \\(\\omega_0\\) (via pendulum length or mass) to match environmental frequencies enhances power output, calculated as \\(P = \\frac{1}{2} b (\\dot{\\theta})^2\\) in the mechanical domain, then converted electrically. Nonlinear effects ( \\(\\sin\\theta\\) ) inform designs for large-amplitude vibrations, preventing chaotic inefficiencies.","title":"Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges_1","text":"Insights into resonance and damping guide bridge design. Excessive amplitude at \\(\\omega \\approx \\omega_0\\) risks structural failure, as \\(R\\) grows inversely with \\(\\gamma\\) . Engineers increase \\(\\gamma\\) (e.g., via dampers) to reduce \\(Q = \\omega_0/(2\\gamma)\\) , the quality factor, mitigating oscillations. The nonlinear transition to chaos warns of unpredictable large swings under strong forcing \\(f\\) , prompting aerodynamic adjustments or cable reinforcements.","title":"Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-circuits_1","text":"The steady-state response \\(R\\) and phase \\(\\phi\\) : \\[ R = \\frac{V_0 / L}{\\sqrt{\\left(\\frac{1}{LC} - \\omega^2\\right)^2 + \\left(\\frac{R}{L} \\omega\\right)^2}}, \\quad \\tan\\phi = \\frac{R \\omega}{\\frac{1}{LC} - \\omega^2}, \\] inform circuit tuning. Resonance at \\(\\omega = 1/\\sqrt{LC}\\) amplifies signals in radios, while damping \\(R/L\\) controls bandwidth. Nonlinear analogs (e.g., with varactors) leverage chaotic dynamics for secure communication or signal processing, drawing from the pendulum\u2019s sensitivity to parameters.","title":"Oscillating Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum encapsulates a rich spectrum of physical behaviors, bridging theoretical nonlinear dynamics with practical engineering applications. The governing equation: \\[ \\frac{d^2 \\theta}{dt^2} + 2\\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = f \\cos(\\omega t), \\] where \\(\\gamma = b/(2m l)\\) , \\(\\omega_0 = \\sqrt{g/l}\\) , and \\(f = F_0/(m l)\\) , provides a foundation for understanding oscillatory systems under damping and external forcing. In the small-angle regime ( \\(\\sin\\theta \\approx \\theta\\) ), the solution: \\[ \\theta(t) = e^{-\\gamma t} (A \\cos(\\omega_d t) + B \\sin(\\omega_d t)) + R \\cos(\\omega t - \\phi), \\] with \\(R = \\frac{f}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma \\omega)^2}}\\) , reveals resonance near \\(\\omega_r \\approx \\sqrt{\\omega_0^2 - 2\\gamma^2}\\) , offering predictable energy amplification critical for applications like energy harvesting and circuit tuning. Analysis of system dynamics highlights the roles of damping \\(\\gamma\\) , driving amplitude \\(f\\) , and frequency \\(\\omega\\) . Higher \\(\\gamma\\) stabilizes motion by reducing \\(R\\) , while large \\(f\\) and specific \\(\\omega/\\omega_0\\) ratios can trigger transitions from regular, periodic trajectories to chaotic, aperiodic ones, marked by a positive Lyapunov exponent \\(\\lambda > 0\\) . This duality\u2014regular motion\u2019s predictability versus chaos\u2019s sensitivity\u2014underscores the system\u2019s complexity. Practically, the model informs energy harvesting by optimizing \\(\\omega_0\\) for resonance, enhances suspension bridge stability by tuning \\(\\gamma\\) to mitigate \\(Q = \\omega_0/(2\\gamma)\\) , and guides oscillating circuits via analogies to RLC dynamics, where \\(R = \\frac{V_0 / L}{\\sqrt{\\left(\\frac{1}{LC} - \\omega^2\\right)^2 + \\left(\\frac{R}{L} \\omega\\right)^2}}\\) . Nonlinear insights further address large-amplitude effects and chaotic potential, from preventing bridge collapse to enabling advanced signal processing. In sum, the forced damped pendulum exemplifies how fundamental physics principles\u2014linear resonance, nonlinear transitions, and parameter interplay\u2014translate into real-world solutions, advancing both theoretical understanding and technological innovation.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#website-with-pendulum-simulations","text":"Pendulum Simulator","title":"Website with pendulum simulations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#basic-simulation-and-motion-plot","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the pendulum ODE def pendulum_deriv(state, t, gamma, omega0_sq, f, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega0_sq * np.sin(theta) + f * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.81 # gravitational acceleration (m/s^2) l = 1.0 # pendulum length (m) omega0_sq = g / l # natural frequency squared t = np.linspace(0, 50, 10000) # time array # Simulation function def simulate_pendulum(gamma, f, omega, theta0=0.2, theta_dot0=0.0): state0 = [theta0, theta_dot0] sol = odeint(pendulum_deriv, state0, t, args=(gamma, omega0_sq, f, omega)) return sol[:, 0], sol[:, 1] # theta, theta_dot # Example cases plt.figure(figsize=(10, 6)) # Case 1: Low damping, near resonance theta1, theta_dot1 = simulate_pendulum(gamma=0.1, f=0.5, omega=3.0) plt.subplot(2, 1, 1) plt.plot(t, theta1) plt.title(\"Motion: \u03b3=0.1, f=0.5, \u03c9=3.0 (Near Resonance)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") # Case 2: High amplitude, chaotic theta2, theta_dot2 = simulate_pendulum(gamma=0.1, f=1.2, omega=2.0) plt.subplot(2, 1, 2) plt.plot(t, theta2) plt.title(\"Motion: \u03b3=0.1, f=1.2, \u03c9=2.0 (Chaotic)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") plt.tight_layout() plt.show()","title":"Basic Simulation and Motion Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-portrait-generation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the pendulum ODE def pendulum_deriv(state, t, gamma, omega0_sq, f, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega0_sq * np.sin(theta) + f * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.81 l = 1.0 omega0_sq = g / l t = np.linspace(0, 50, 10000) # Simulation function def simulate_pendulum(gamma, f, omega, theta0=0.2, theta_dot0=0.0): state0 = [theta0, theta_dot0] sol = odeint(pendulum_deriv, state0, t, args=(gamma, omega0_sq, f, omega)) return sol[:, 0], sol[:, 1] # Plot phase portraits plt.figure(figsize=(10, 6)) # Case 1: Low damping, near resonance theta1, theta_dot1 = simulate_pendulum(gamma=0.1, f=0.5, omega=3.0) plt.subplot(1, 2, 1) plt.plot(theta1, theta_dot1, lw=0.5) plt.title(\"Phase Portrait: \u03b3=0.1, f=0.5, \u03c9=3.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Case 2: High amplitude, chaotic theta2, theta_dot2 = simulate_pendulum(gamma=0.1, f=1.2, omega=2.0) plt.subplot(1, 2, 2) plt.plot(theta2, theta_dot2, lw=0.5) plt.title(\"Phase Portrait: \u03b3=0.1, f=1.2, \u03c9=2.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show()","title":"Phase Portrait Generation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section-generation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Define the pendulum ODE def pendulum_deriv(state, t, gamma, omega0_sq, f, omega): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -2 * gamma * theta_dot - omega0_sq * np.sin(theta) + f * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # Parameters g = 9.81 l = 1.0 omega0_sq = g / l t = np.linspace(0, 50, 10000) # Simulation function def simulate_pendulum(gamma, f, omega, theta0=0.2, theta_dot0=0.0): state0 = [theta0, theta_dot0] sol = odeint(pendulum_deriv, state0, t, args=(gamma, omega0_sq, f, omega)) return sol[:, 0], sol[:, 1] # Poincar\u00e9 section function def poincare_section(theta, theta_dot, t, omega): period = 2 * np.pi / omega indices = np.where(np.abs(t % period) < 0.01)[0] return theta[indices], theta_dot[indices] # Plot Poincar\u00e9 sections plt.figure(figsize=(10, 6)) # Case 1: Low damping, near resonance theta1, theta_dot1 = simulate_pendulum(gamma=0.1, f=0.5, omega=3.0) p_theta1, p_theta_dot1 = poincare_section(theta1, theta_dot1, t, 3.0) plt.subplot(1, 2, 1) plt.scatter(p_theta1, p_theta_dot1, s=1) plt.title(\"Poincar\u00e9: \u03b3=0.1, f=0.5, \u03c9=3.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Case 2: High amplitude, chaotic theta2, theta_dot2 = simulate_pendulum(gamma=0.1, f=1.2, omega=2.0) p_theta2, p_theta_dot2 = poincare_section(theta2, theta_dot2, t, 2.0) plt.subplot(1, 2, 2) plt.scatter(p_theta2, p_theta_dot2, s=1) plt.title(\"Poincar\u00e9: \u03b3=0.1, f=1.2, \u03c9=2.0\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show()","title":"Poincar\u00e9 Section Generation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagram-generation","text":"import numpy as np import matplotlib.pyplot as plt def logistic_map(r, x): return r * x * (1 - x) def bifurcation_diagram(r_min=2.5, r_max=4.0, num_r=10000, num_iter=1000, num_last=100): r_values = np.linspace(r_min, r_max, num_r) x = 0.5 * np.ones(num_r) plt.figure(figsize=(10, 6), dpi=100) for _ in range(num_iter): x = logistic_map(r_values, x) if _ >= (num_iter - num_last): plt.plot(r_values, x, ',k', alpha=0.25) plt.xlim(r_min, r_max) plt.ylim(0, 1) plt.xlabel(\"r\") plt.ylabel(\"x\") plt.title(\"Bifurcation Diagram of the Logistic Map\") plt.show() # Run the bifurcation diagram function bifurcation_diagram()","title":"Bifurcation Diagram Generation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Derivation of the Relationship Between Orbital Period and Orbital Radius The following notes derive the relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ) for an object in a circular orbit, culminating in a form consistent with Kepler's Third Law. This derivation integrates Newton\u2019s law of universal gravitation with the dynamics of circular motion, providing a foundational result in celestial mechanics. 1. Newton\u2019s Law of Gravitation Newton\u2019s law of gravitation describes the attractive force between two masses. For a satellite of mass \\(m\\) orbiting a central body of mass \\(M\\) (where \\(M \\gg m\\) ), the gravitational force \\(F_g\\) is given by: \\[ F_g = \\frac{G M m}{r^2} \\] where: - \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), - \\(M\\) is the mass of the central body, - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius (distance between the centers of the two masses). This force acts as the centripetal force required to maintain the satellite in a circular orbit. 2. Centripetal Force for Circular Motion For an object in uniform circular motion, the centripetal force \\(F_c\\) is necessary to keep it moving along a circular path. The expression for centripetal force is: \\[ F_c = \\frac{m v^2}{r} \\] where: - \\(v\\) is the orbital velocity of the satellite, - \\(m\\) is the mass of the satellite, - \\(r\\) is the radius of the circular orbit. The orbital velocity \\(v\\) can be related to the orbital period \\(T\\) , the time for one complete revolution. The circumference of the orbit is \\(2\\pi r\\) , so: \\[ v = \\frac{2\\pi r}{T} \\] Squaring this velocity: \\[ v^2 = \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{4\\pi^2 r^2}{T^2} \\] Substituting \\(v^2\\) into the centripetal force equation: \\[ F_c = \\frac{m}{r} \\cdot \\frac{4\\pi^2 r^2}{T^2} = \\frac{4\\pi^2 m r}{T^2} \\] 3. Equating Gravitational and Centripetal Forces In a stable circular orbit, the gravitational force provides the necessary centripetal force. Thus, we set \\(F_g = F_c\\) : \\[ \\frac{G M m}{r^2} = \\frac{4\\pi^2 m r}{T^2} \\] The mass of the satellite \\(m\\) appears on both sides and, assuming \\(m \\neq 0\\) , can be canceled: \\[ \\frac{G M}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] 4. Solving for the Orbital Period-Radius Relationship To isolate the relationship between \\(T\\) and \\(r\\) , rearrange the equation. Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Now, divide through by \\(G M\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This equation reveals that the square of the orbital period \\(T^2\\) is directly proportional to the cube of the orbital radius \\(r^3\\) . The constant of proportionality, \\(\\frac{4\\pi^2}{G M}\\) , depends only on the mass of the central body \\(M\\) and universal constants. 5. Consistency with Kepler\u2019s Third Law Kepler\u2019s Third Law, originally empirical, states that for planets orbiting the Sun, the ratio \\(T^2 / r^3\\) is constant. In Newtonian terms, we rewrite: \\[ T^2 = k r^3 \\] where \\(k = \\frac{4\\pi^2}{G M}\\) is constant for all bodies orbiting the same central mass \\(M\\) . This confirms that our derivation aligns with Kepler\u2019s Third Law for circular orbits. For a given system (e.g., the Solar System), \\(M\\) is the mass of the Sun, and \\(k\\) is identical for all planets assuming circular orbits. To express this in a more familiar form, take the ratio for two orbiting bodies (e.g., planets 1 and 2): \\[ \\frac{T_1^2}{r_1^3} = \\frac{T_2^2}{r_2^3} \\] This dimensionless form emphasizes the universality of the relationship across a single gravitational system. Implications of the Orbital Period-Radius Relationship in Astronomy The relationship \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) , derived from Newtonian mechanics, underpins critical astronomical applications. This section explores how it enables the determination of central body masses, facilitates distance measurements between celestial bodies, and enhances our understanding of gravitational interactions in planetary systems and satellite orbits. 1. Calculating the Mass of a Central Body The derived relationship allows astronomers to infer the mass of a central body \\(M\\) (e.g., a star or planet) when the orbital period \\(T\\) and radius \\(r\\) of a satellite or orbiting body are measurable. Rearranging the equation for \\(M\\) : \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Here, \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), \\(r\\) is the orbital radius, and \\(T\\) is the orbital period. For example, consider Earth\u2019s Moon: with \\(T \\approx 27.32 \\, \\text{days}\\) (converted to seconds, \\(T \\approx 2.36 \\times 10^6 \\, \\text{s}\\) ) and \\(r \\approx 3.84 \\times 10^8 \\, \\text{m}\\) , astronomers can compute Earth\u2019s mass \\(M\\) . This method is widely applied beyond the Solar System. For a binary star system, if one star\u2019s orbit has a measured period \\(T_1\\) and semi-major axis \\(r_1\\) (approximated as \\(r\\) for circular orbits), the total system mass can be estimated, assuming the companion\u2019s contribution is accounted for via the center-of-mass relation. 2. Determining Distances Between Celestial Bodies The \\(T^2 \\propto r^3\\) relationship also aids in measuring distances between celestial bodies, such as planets or moons, when paired with observational data. If \\(M\\) is known (e.g., the Sun\u2019s mass, \\(M_\\odot \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) ), and \\(T\\) is observed (e.g., via transit timing or Doppler shifts), the orbital radius \\(r\\) can be solved: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] For instance, knowing Earth\u2019s orbital period around the Sun ( \\(T \\approx 365.25 \\, \\text{days} \\approx 3.156 \\times 10^7 \\, \\text{s}\\) ), astronomers calculate its mean distance \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU). This technique extends to exoplanets: if an exoplanet\u2019s period is detected via light curve dips, its distance from its host star can be inferred, assuming the star\u2019s mass is estimated from stellar models. For moons, the method refines distances from their planets. The Moon\u2019s \\(r\\) was historically constrained using its period and Earth\u2019s mass, validated by modern laser ranging. 3. Significance in Understanding Gravitational Interactions The relationship illuminates gravitational dynamics across scales. In planetary systems, it governs stability: perturbations in \\(r\\) or \\(T\\) signal additional masses (e.g., undiscovered planets) via deviations from the expected \\(T^2/r^3\\) ratio. For the Solar System, Kepler\u2019s Third Law holds approximately for planets, with slight elliptical corrections: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} = \\frac{4\\pi^2}{G M_\\odot} \\] For satellite orbits, the equation informs design. Geostationary satellites, with \\(T = 24 \\, \\text{hours} \\approx 86,400 \\, \\text{s}\\) , orbit at \\(r \\approx 42,164 \\, \\text{km}\\) from Earth\u2019s center, derived from: \\[ r = \\left( \\frac{G M_\\oplus T^2}{4\\pi^2} \\right)^{1/3} \\] where \\(M_\\oplus \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) . This precision ensures communication satellites maintain fixed positions relative to Earth. Moreover, the law\u2019s universality\u2014applicable to moons, planets, and artificial satellites\u2014underscores gravity\u2019s consistent role. In multi-body systems, deviations from the ideal \\(T^2 \\propto r^3\\) form reveal tidal effects or companion influences, as seen in Jupiter\u2019s Galilean moons. Analysis of Real-World Examples: Orbital Period and Radius Kepler\u2019s Third Law, expressed as \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) for circular orbits, implies that the ratio \\(T^2/r^3\\) is constant for objects orbiting the same central body. This section collects orbital data for the Moon around Earth and for Earth and Mars around the Sun, then compares these to demonstrate the law\u2019s consistency across systems. 1. Data Collection: Moon\u2019s Orbit Around Earth The Moon orbits Earth with the following approximate parameters: - Orbital Period ( \\(T\\) ) : The sidereal period is \\(27.322\\) days, or \\(T_m = 27.322 \\times 86,400 = 2.36 \\times 10^6 \\, \\text{s}\\) (converting days to seconds). - Orbital Radius ( \\(r\\) ) : The average distance is \\(r_m = 3.844 \\times 10^8 \\, \\text{m}\\) , based on lunar ranging data. Calculate \\(T_m^2\\) and \\(r_m^3\\) : - \\(T_m^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2\\) , - \\(r_m^3 = (3.844 \\times 10^8)^3 = 5.67 \\times 10^{25} \\, \\text{m}^3\\) . Thus, the ratio: $$ \\frac{T_m^2}{r_m^3} = \\frac{5.57 \\times 10^{12}}{5.67 \\times 10^{25}} \\approx 9.82 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3}. $$ This depends on Earth\u2019s mass \\(M_\\oplus\\) via $$ \\frac{4\\pi^2}{G M_\\oplus}, $$ where $$ G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ and $$ M_\\oplus \\approx 5.972 \\times 10^{24} \\, \\text{kg}. $$ Conclusion The relationship \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) , derived from gravitational and circular motion dynamics, is a cornerstone of celestial mechanics. It links a central mass \\(M\\) , orbital radius \\(r\\) , and period \\(T\\) , enabling calculations of orbital periods, radii, and central body masses. Its applications range from the Solar System to exoplanetary studies, where it aids in characterizing distant worlds. Observational data confirm its consistency: the \\(T^2/r^3\\) ratio reflects the central mass, with the Moon\u2019s ratio tied to Earth\u2019s mass ( \\(M_\\oplus\\) ) and Earth and Mars sharing a ratio linked to the Sun\u2019s mass ( \\(M_\\odot\\) ). This universality validates Kepler\u2019s Third Law for circular orbits, with theoretical values aligning closely with empirical results. Beyond practical uses, this relationship underscores Newtonian gravity\u2019s predictive power, bridging local and cosmic scales. It also serves as a foundation for exploring elliptical orbits and broader celestial dynamics. Visualizations Website with orbit simulation Orbit Simulation Kepler Third Law (log scale) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 1.989e30 # Orbital radii in meters (planets in the Solar System, in AU converted to meters) au_to_m = 1.496e11 planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"] radii_au = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.2, 30.1]) radii = radii_au * au_to_m # Convert to meters periods = np.sqrt(4 * np.pi**2 * radii**3 / (G * M)) # Kepler's Third Law # Compute log values to make them more readable log_r3 = np.log10(radii**3) log_T2 = np.log10(periods**2) # Plot T^2 vs. r^3 using log-log scale plt.figure(figsize=(8, 6)) plt.scatter(log_r3, log_T2, color='b', label=r'$T^2 \\propto r^3$') # Add planet labels with adjusted positions to avoid overlap for i, planet in enumerate(planets): plt.text(log_r3[i], log_T2[i] + 0.1, planet, fontsize=10, ha='center', va='bottom') plt.xlabel(r\"$\\log_{10}(r^3) \\, (m^3)$\") plt.ylabel(r\"$\\log_{10}(T^2) \\, (s^2)$\") plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$ (Log Scale)\") plt.legend() plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5) plt.show() Planetary Orbit Animation import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant M = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical unit (m) # Define a planet's orbit r = 1.0 * AU # 1 AU T = np.sqrt(4 * np.pi**2 * r**3 / (G * M)) # Orbital period # Time values num_frames = 200 # Number of frames for smooth animation t = np.linspace(0, T, num_frames) theta = 2 * np.pi * t / T # Orbital positions x = r * np.cos(theta) y = r * np.sin(theta) # Create figure fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2 * AU, 1.2 * AU) ax.set_ylim(-1.2 * AU, 1.2 * AU) ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_title(\"Planetary Orbit Animation\") ax.grid() # Plot Sun ax.plot(0, 0, 'yo', markersize=12, label=\"Sun\") # Planet marker planet, = ax.plot([], [], 'bo', markersize=8, label=\"Planet\") # Animation function def update(frame): planet.set_data([x[frame]], [y[frame]]) # Ensure data is passed as a sequence return planet, # Create animation ani = animation.FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # Save as GIF ani.save(\"/content/orbit_animation.gif\", writer=\"pillow\", fps=20) # Display in Colab HTML(ani.to_jshtml()) Colab Colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-relationship-between-orbital-period-and-orbital-radius","text":"The following notes derive the relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ) for an object in a circular orbit, culminating in a form consistent with Kepler's Third Law. This derivation integrates Newton\u2019s law of universal gravitation with the dynamics of circular motion, providing a foundational result in celestial mechanics.","title":"Derivation of the Relationship Between Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-newtons-law-of-gravitation","text":"Newton\u2019s law of gravitation describes the attractive force between two masses. For a satellite of mass \\(m\\) orbiting a central body of mass \\(M\\) (where \\(M \\gg m\\) ), the gravitational force \\(F_g\\) is given by: \\[ F_g = \\frac{G M m}{r^2} \\] where: - \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), - \\(M\\) is the mass of the central body, - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius (distance between the centers of the two masses). This force acts as the centripetal force required to maintain the satellite in a circular orbit.","title":"1. Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-centripetal-force-for-circular-motion","text":"For an object in uniform circular motion, the centripetal force \\(F_c\\) is necessary to keep it moving along a circular path. The expression for centripetal force is: \\[ F_c = \\frac{m v^2}{r} \\] where: - \\(v\\) is the orbital velocity of the satellite, - \\(m\\) is the mass of the satellite, - \\(r\\) is the radius of the circular orbit. The orbital velocity \\(v\\) can be related to the orbital period \\(T\\) , the time for one complete revolution. The circumference of the orbit is \\(2\\pi r\\) , so: \\[ v = \\frac{2\\pi r}{T} \\] Squaring this velocity: \\[ v^2 = \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{4\\pi^2 r^2}{T^2} \\] Substituting \\(v^2\\) into the centripetal force equation: \\[ F_c = \\frac{m}{r} \\cdot \\frac{4\\pi^2 r^2}{T^2} = \\frac{4\\pi^2 m r}{T^2} \\]","title":"2. Centripetal Force for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-equating-gravitational-and-centripetal-forces","text":"In a stable circular orbit, the gravitational force provides the necessary centripetal force. Thus, we set \\(F_g = F_c\\) : \\[ \\frac{G M m}{r^2} = \\frac{4\\pi^2 m r}{T^2} \\] The mass of the satellite \\(m\\) appears on both sides and, assuming \\(m \\neq 0\\) , can be canceled: \\[ \\frac{G M}{r^2} = \\frac{4\\pi^2 r}{T^2} \\]","title":"3. Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-solving-for-the-orbital-period-radius-relationship","text":"To isolate the relationship between \\(T\\) and \\(r\\) , rearrange the equation. Multiply both sides by \\(T^2\\) : \\[ G M T^2 = 4\\pi^2 r^3 \\] Now, divide through by \\(G M\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This equation reveals that the square of the orbital period \\(T^2\\) is directly proportional to the cube of the orbital radius \\(r^3\\) . The constant of proportionality, \\(\\frac{4\\pi^2}{G M}\\) , depends only on the mass of the central body \\(M\\) and universal constants.","title":"4. Solving for the Orbital Period-Radius Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-consistency-with-keplers-third-law","text":"Kepler\u2019s Third Law, originally empirical, states that for planets orbiting the Sun, the ratio \\(T^2 / r^3\\) is constant. In Newtonian terms, we rewrite: \\[ T^2 = k r^3 \\] where \\(k = \\frac{4\\pi^2}{G M}\\) is constant for all bodies orbiting the same central mass \\(M\\) . This confirms that our derivation aligns with Kepler\u2019s Third Law for circular orbits. For a given system (e.g., the Solar System), \\(M\\) is the mass of the Sun, and \\(k\\) is identical for all planets assuming circular orbits. To express this in a more familiar form, take the ratio for two orbiting bodies (e.g., planets 1 and 2): \\[ \\frac{T_1^2}{r_1^3} = \\frac{T_2^2}{r_2^3} \\] This dimensionless form emphasizes the universality of the relationship across a single gravitational system.","title":"5. Consistency with Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-the-orbital-period-radius-relationship-in-astronomy","text":"The relationship \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) , derived from Newtonian mechanics, underpins critical astronomical applications. This section explores how it enables the determination of central body masses, facilitates distance measurements between celestial bodies, and enhances our understanding of gravitational interactions in planetary systems and satellite orbits.","title":"Implications of the Orbital Period-Radius Relationship in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-calculating-the-mass-of-a-central-body","text":"The derived relationship allows astronomers to infer the mass of a central body \\(M\\) (e.g., a star or planet) when the orbital period \\(T\\) and radius \\(r\\) of a satellite or orbiting body are measurable. Rearranging the equation for \\(M\\) : \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Here, \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ), \\(r\\) is the orbital radius, and \\(T\\) is the orbital period. For example, consider Earth\u2019s Moon: with \\(T \\approx 27.32 \\, \\text{days}\\) (converted to seconds, \\(T \\approx 2.36 \\times 10^6 \\, \\text{s}\\) ) and \\(r \\approx 3.84 \\times 10^8 \\, \\text{m}\\) , astronomers can compute Earth\u2019s mass \\(M\\) . This method is widely applied beyond the Solar System. For a binary star system, if one star\u2019s orbit has a measured period \\(T_1\\) and semi-major axis \\(r_1\\) (approximated as \\(r\\) for circular orbits), the total system mass can be estimated, assuming the companion\u2019s contribution is accounted for via the center-of-mass relation.","title":"1. Calculating the Mass of a Central Body"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-determining-distances-between-celestial-bodies","text":"The \\(T^2 \\propto r^3\\) relationship also aids in measuring distances between celestial bodies, such as planets or moons, when paired with observational data. If \\(M\\) is known (e.g., the Sun\u2019s mass, \\(M_\\odot \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) ), and \\(T\\) is observed (e.g., via transit timing or Doppler shifts), the orbital radius \\(r\\) can be solved: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] For instance, knowing Earth\u2019s orbital period around the Sun ( \\(T \\approx 365.25 \\, \\text{days} \\approx 3.156 \\times 10^7 \\, \\text{s}\\) ), astronomers calculate its mean distance \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU). This technique extends to exoplanets: if an exoplanet\u2019s period is detected via light curve dips, its distance from its host star can be inferred, assuming the star\u2019s mass is estimated from stellar models. For moons, the method refines distances from their planets. The Moon\u2019s \\(r\\) was historically constrained using its period and Earth\u2019s mass, validated by modern laser ranging.","title":"2. Determining Distances Between Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-significance-in-understanding-gravitational-interactions","text":"The relationship illuminates gravitational dynamics across scales. In planetary systems, it governs stability: perturbations in \\(r\\) or \\(T\\) signal additional masses (e.g., undiscovered planets) via deviations from the expected \\(T^2/r^3\\) ratio. For the Solar System, Kepler\u2019s Third Law holds approximately for planets, with slight elliptical corrections: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} = \\frac{4\\pi^2}{G M_\\odot} \\] For satellite orbits, the equation informs design. Geostationary satellites, with \\(T = 24 \\, \\text{hours} \\approx 86,400 \\, \\text{s}\\) , orbit at \\(r \\approx 42,164 \\, \\text{km}\\) from Earth\u2019s center, derived from: \\[ r = \\left( \\frac{G M_\\oplus T^2}{4\\pi^2} \\right)^{1/3} \\] where \\(M_\\oplus \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) . This precision ensures communication satellites maintain fixed positions relative to Earth. Moreover, the law\u2019s universality\u2014applicable to moons, planets, and artificial satellites\u2014underscores gravity\u2019s consistent role. In multi-body systems, deviations from the ideal \\(T^2 \\propto r^3\\) form reveal tidal effects or companion influences, as seen in Jupiter\u2019s Galilean moons.","title":"3. Significance in Understanding Gravitational Interactions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#analysis-of-real-world-examples-orbital-period-and-radius","text":"Kepler\u2019s Third Law, expressed as \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) for circular orbits, implies that the ratio \\(T^2/r^3\\) is constant for objects orbiting the same central body. This section collects orbital data for the Moon around Earth and for Earth and Mars around the Sun, then compares these to demonstrate the law\u2019s consistency across systems.","title":"Analysis of Real-World Examples: Orbital Period and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-data-collection-moons-orbit-around-earth","text":"The Moon orbits Earth with the following approximate parameters: - Orbital Period ( \\(T\\) ) : The sidereal period is \\(27.322\\) days, or \\(T_m = 27.322 \\times 86,400 = 2.36 \\times 10^6 \\, \\text{s}\\) (converting days to seconds). - Orbital Radius ( \\(r\\) ) : The average distance is \\(r_m = 3.844 \\times 10^8 \\, \\text{m}\\) , based on lunar ranging data. Calculate \\(T_m^2\\) and \\(r_m^3\\) : - \\(T_m^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2\\) , - \\(r_m^3 = (3.844 \\times 10^8)^3 = 5.67 \\times 10^{25} \\, \\text{m}^3\\) . Thus, the ratio: $$ \\frac{T_m^2}{r_m^3} = \\frac{5.57 \\times 10^{12}}{5.67 \\times 10^{25}} \\approx 9.82 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3}. $$ This depends on Earth\u2019s mass \\(M_\\oplus\\) via $$ \\frac{4\\pi^2}{G M_\\oplus}, $$ where $$ G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} $$ and $$ M_\\oplus \\approx 5.972 \\times 10^{24} \\, \\text{kg}. $$","title":"1. Data Collection: Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"The relationship \\(T^2 = \\frac{4\\pi^2}{G M} r^3\\) , derived from gravitational and circular motion dynamics, is a cornerstone of celestial mechanics. It links a central mass \\(M\\) , orbital radius \\(r\\) , and period \\(T\\) , enabling calculations of orbital periods, radii, and central body masses. Its applications range from the Solar System to exoplanetary studies, where it aids in characterizing distant worlds. Observational data confirm its consistency: the \\(T^2/r^3\\) ratio reflects the central mass, with the Moon\u2019s ratio tied to Earth\u2019s mass ( \\(M_\\oplus\\) ) and Earth and Mars sharing a ratio linked to the Sun\u2019s mass ( \\(M_\\odot\\) ). This universality validates Kepler\u2019s Third Law for circular orbits, with theoretical values aligning closely with empirical results. Beyond practical uses, this relationship underscores Newtonian gravity\u2019s predictive power, bridging local and cosmic scales. It also serves as a foundation for exploring elliptical orbits and broader celestial dynamics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualizations","text":"","title":"Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#website-with-orbit-simulation","text":"Orbit Simulation","title":"Website with orbit simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#kepler-third-law-log-scale","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 1.989e30 # Orbital radii in meters (planets in the Solar System, in AU converted to meters) au_to_m = 1.496e11 planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"] radii_au = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.2, 30.1]) radii = radii_au * au_to_m # Convert to meters periods = np.sqrt(4 * np.pi**2 * radii**3 / (G * M)) # Kepler's Third Law # Compute log values to make them more readable log_r3 = np.log10(radii**3) log_T2 = np.log10(periods**2) # Plot T^2 vs. r^3 using log-log scale plt.figure(figsize=(8, 6)) plt.scatter(log_r3, log_T2, color='b', label=r'$T^2 \\propto r^3$') # Add planet labels with adjusted positions to avoid overlap for i, planet in enumerate(planets): plt.text(log_r3[i], log_T2[i] + 0.1, planet, fontsize=10, ha='center', va='bottom') plt.xlabel(r\"$\\log_{10}(r^3) \\, (m^3)$\") plt.ylabel(r\"$\\log_{10}(T^2) \\, (s^2)$\") plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$ (Log Scale)\") plt.legend() plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5) plt.show()","title":"Kepler Third Law (log scale)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planetary-orbit-animation","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Constants G = 6.67430e-11 # Gravitational constant M = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical unit (m) # Define a planet's orbit r = 1.0 * AU # 1 AU T = np.sqrt(4 * np.pi**2 * r**3 / (G * M)) # Orbital period # Time values num_frames = 200 # Number of frames for smooth animation t = np.linspace(0, T, num_frames) theta = 2 * np.pi * t / T # Orbital positions x = r * np.cos(theta) y = r * np.sin(theta) # Create figure fig, ax = plt.subplots(figsize=(6,6)) ax.set_xlim(-1.2 * AU, 1.2 * AU) ax.set_ylim(-1.2 * AU, 1.2 * AU) ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_title(\"Planetary Orbit Animation\") ax.grid() # Plot Sun ax.plot(0, 0, 'yo', markersize=12, label=\"Sun\") # Planet marker planet, = ax.plot([], [], 'bo', markersize=8, label=\"Planet\") # Animation function def update(frame): planet.set_data([x[frame]], [y[frame]]) # Ensure data is passed as a sequence return planet, # Create animation ani = animation.FuncAnimation(fig, update, frames=num_frames, interval=50, blit=True) # Save as GIF ani.save(\"/content/orbit_animation.gif\", writer=\"pillow\", fps=20) # Display in Colab HTML(ani.to_jshtml())","title":"Planetary Orbit Animation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities: Definitions and Physical Meaning Introduction The study of cosmic velocities is foundational to celestial mechanics and space exploration. These velocities\u2014first, second, and third\u2014represent critical thresholds for overcoming gravitational forces at various scales. This section defines each velocity, derives their physical significance, and elucidates their roles in gravitational dynamics. 1. First Cosmic Velocity (Orbital Velocity) The first cosmic velocity , denoted \\(v_1\\) , is the minimum speed required for an object to maintain a circular orbit around a celestial body at its surface. It arises from balancing the centripetal force required for circular motion with the gravitational force exerted by the body. The gravitational force on an object of mass \\(m\\) at the surface of a body with mass \\(M\\) and radius \\(R\\) is given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{R^2}, $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). For circular motion, the centripetal force is provided by gravity, such that: $$ F_c = \\frac{m v_1^2}{R} = F_g. $$ Equating these forces: $$ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2}. $$ Canceling \\(m\\) (assuming \\(m \\neq 0\\) ) and simplifying: $$ v_1^2 = \\frac{G M}{R}. $$ Thus, the first cosmic velocity is: $$ v_1 = \\sqrt{\\frac{G M}{R}}. $$ Physical Meaning The velocity \\(v_1\\) represents the threshold where an object\u2019s kinetic energy per unit mass, \\(\\frac{1}{2} v_1^2\\) , equals the gravitational potential energy per unit mass at the surface, adjusted for circular motion. For Earth ( \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) ), \\(v_1 \\approx 7.91 \\, \\text{km/s}\\) . This speed enables satellites to orbit without escaping or falling back. 2. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity , denoted \\(v_2\\) , is the minimum speed required to escape a celestial body\u2019s gravitational influence entirely, assuming no atmospheric drag or external forces. It corresponds to the point where the total mechanical energy (kinetic plus potential) becomes zero at infinity. The gravitational potential energy at distance \\(r\\) from the center of mass is: $$ U = -\\frac{G M m}{r}. $$ At the surface ( \\(r = R\\) ), the potential energy is \\(-\\frac{G M m}{R}\\) . To escape, the kinetic energy at launch must equal the magnitude of this potential energy: $$ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R}. $$ Canceling \\(m\\) and solving: $$ v_2^2 = \\frac{2 G M}{R}, $$ $$ v_2 = \\sqrt{\\frac{2 G M}{R}}. $$ Notably, comparing \\(v_2\\) to \\(v_1\\) : $$ v_2 = \\sqrt{2} \\cdot v_1, $$ since \\(\\frac{2 G M}{R} = 2 \\cdot \\frac{G M}{R}\\) . Physical Meaning The escape velocity \\(v_2\\) signifies the condition where an object\u2019s kinetic energy, \\(\\frac{1}{2} v_2^2 = \\frac{G M}{R}\\) , exactly cancels the negative potential energy, allowing it to reach infinity with zero residual speed. For Earth, \\(v_2 \\approx 11.19 \\, \\text{km/s}\\) , critical for lunar or interplanetary missions. 3. Third Cosmic Velocity (System Escape Velocity) The third cosmic velocity , denoted \\(v_3\\) , is the speed required to escape the gravitational influence of a star system (e.g., the Solar System) from a given starting point, such as a planet\u2019s surface. It builds on \\(v_2\\) by accounting for the star\u2019s gravitational pull (e.g., the Sun). Consider an object escaping Earth\u2019s gravity ( \\(v_2\\) ) while orbiting the Sun (mass \\(M_s\\) , distance from Sun \\(R_s\\) ). The total energy in the heliocentric frame must be zero or positive to escape the Solar System. The energy equation at Earth\u2019s orbit is complex, but an approximation from Earth\u2019s surface involves: - Earth escape: \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) , - Additional velocity to escape the Sun\u2019s gravity from Earth\u2019s orbital radius. The Sun\u2019s potential at Earth\u2019s distance ( \\(R_s \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) ) is: $$ U_s = -\\frac{G M_s m}{R_s}. $$ Earth\u2019s orbital velocity around the Sun is: $$ v_{\\text{orb}} = \\sqrt{\\frac{G M_s}{R_s}} \\approx 29.78 \\, \\text{km/s}. $$ The velocity to escape the Sun from Earth\u2019s orbit is: $$ v_{\\text{esc,s}} = \\sqrt{2} \\cdot v_{\\text{orb}} \\approx 42.1 \\, \\text{km/s}. $$ The third cosmic velocity combines Earth escape and Solar escape, approximated as: $$ v_3 \\approx \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2}. $$ For Earth, \\(v_3 \\approx 16.6 \\, \\text{km/s}\\) from the surface, though exact values depend on trajectory. Physical Meaning The velocity \\(v_3\\) reflects the energy needed to overcome both planetary and stellar gravitational wells, enabling interstellar travel. It underscores the immense challenge of escaping a star system, as the kinetic energy must satisfy: $$ \\frac{1}{2} m v_3^2 \\geq \\frac{G M m}{R} + \\frac{G M_s m}{R_s}. $$ Conclusion The first, second, and third cosmic velocities\u2014 \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) \u2014define the energetic thresholds for orbiting, escaping a planet, and escaping a star system, respectively. Their derivations from gravitational and kinetic principles highlight their universal applicability in space exploration. Escape Velocities and Cosmic Velocities: Mathematical Derivations Introduction The cosmic velocities\u2014first ( \\(v_1\\) ), second ( \\(v_2\\) ), and third ( \\(v_3\\) )\u2014are derived from fundamental principles of classical mechanics, specifically Newton\u2019s law of gravitation and the conservation of mechanical energy. This section identifies the key equations, provides rigorous step-by-step derivations, lists the parameters involved, and analyzes their influence on the resulting velocities. Key Equations The foundational equations for the cosmic velocities are: - First cosmic velocity (orbital velocity): $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ - Second cosmic velocity (escape velocity): $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ - Third cosmic velocity (system escape velocity): $$ v_3 \\approx \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2} $$ Here, \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(R\\) is its radius, \\(M_s\\) is the star\u2019s mass, \\(R_s\\) is the distance from the star, \\(v_{\\text{esc,s}}\\) is the escape velocity from the star, and \\(v_{\\text{orb}}\\) is the orbital velocity around the star. 1. Derivation of the First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the speed required for an object of mass \\(m\\) to maintain a circular orbit at the surface of a celestial body (radius \\(R\\) , mass \\(M\\) ). Step-by-Step Derivation Newton\u2019s Law of Gravitation : The gravitational force provides the centripetal force: $$ F_g = \\frac{G M m}{R^2}. $$ Centripetal Force for Circular Motion : For an object in circular orbit at radius \\(R\\) : $$ F_c = \\frac{m v_1^2}{R}. $$ Equate Forces : Since \\(F_g\\) supplies \\(F_c\\) : $$ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2}. $$ Simplify : Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and multiply both sides by \\(R\\) : $$ v_1^2 = \\frac{G M}{R}. $$ Solve for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{G M}{R}}. $$ Physical Insight The term \\(\\frac{G M}{R}\\) is the gravitational parameter divided by distance, representing the specific energy required for circular motion. 2. Derivation of the Second Cosmic Velocity ( \\(v_2\\) ) The second cosmic velocity is the minimum speed to escape a celestial body\u2019s gravitational field, reaching infinity with zero residual velocity. Step-by-Step Derivation Conservation of Energy : Total mechanical energy (kinetic + potential) is conserved. At the surface: Kinetic energy: $$ K = \\frac{1}{2} m v_2^2 $$ Potential energy: $$ U = -\\frac{G M m}{R} $$ Energy at Infinity : For escape, total energy at \\(r \\to \\infty\\) is zero (where \\(U = 0\\) ): $$ E_{\\text{total}} = K + U = 0. $$ Set Initial Energy : At the surface ( \\(r = R\\) ): $$ \\frac{1}{2} m v_2^2 - \\frac{G M m}{R} = 0. $$ Simplify : Cancel \\(m\\) and solve: $$ \\frac{1}{2} v_2^2 = \\frac{G M}{R}, $$ $$ v_2^2 = \\frac{2 G M}{R}. $$ Solve for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2 G M}{R}}. $$ Relation to \\(v_1\\) : Since \\(v_1^2 = \\frac{G M}{R}\\) , we find: $$ v_2^2 = 2 v_1^2, $$ $$ v_2 = \\sqrt{2} \\cdot v_1. $$ Physical Insight The factor of 2 arises because escape requires doubling the kinetic energy relative to orbiting, overcoming the full potential well. 3. Derivation of the Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is the speed to escape a star system (e.g., the Sun) from a planet\u2019s surface, combining planetary and stellar escape. Step-by-Step Derivation Planetary Escape : From the planet (e.g., Earth), use \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2 G M}{R}}. $$ Stellar Potential : At the planet\u2019s distance from the star ( \\(R_s\\) , \\(M_s\\) ): $$ U_s = -\\frac{G M_s m}{R_s}. $$ Orbital Velocity Around Star : The planet\u2019s orbital speed: $$ v_{\\text{orb}} = \\sqrt{\\frac{G M_s}{R_s}}. $$ Escape Velocity from Star : From the planet\u2019s orbit: $$ v_{\\text{esc,s}} = \\sqrt{\\frac{2 G M_s}{R_s}} = \\sqrt{2} \\cdot v_{\\text{orb}}. $$ Excess Velocity : The additional speed beyond \\(v_{\\text{orb}}\\) to escape the star: $$ v_{\\text{excess}} = v_{\\text{esc,s}} - v_{\\text{orb}}. $$ Total Velocity : Combine velocities vectorially (approximate): $$ v_3^2 = v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2, $$ $$ v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2}. $$ Physical Insight The derivation accounts for two gravitational potentials, requiring a velocity composition that exceeds both local and system-wide escape thresholds. Parameters Involved Gravitational Constant ( \\(G\\) ) : Universal constant, \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) . Mass of Celestial Body ( \\(M\\) ) : Mass of the planet or star. Radius of Celestial Body ( \\(R\\) ) : Distance from the center to the surface. Mass of Star ( \\(M_s\\) ) : For \\(v_3\\) , the star\u2019s mass. Distance from Star ( \\(R_s\\) ) : For \\(v_3\\) , the orbital radius. Influence of Parameters Mass ( \\(M\\) ) : Velocities \\(v_1\\) and \\(v_2\\) increase with \\(M\\) ( \\(v_1, v_2 \\propto \\sqrt{M}\\) ). For \\(v_3\\) , both \\(M\\) and \\(M_s\\) amplify the required speed. $$ \\frac{\\partial v_1}{\\partial M} > 0. $$ Radius ( \\(R\\) ) : Velocities \\(v_1\\) and \\(v_2\\) decrease with \\(R\\) ( \\(v_1, v_2 \\propto \\frac{1}{\\sqrt{R}}\\) ), as gravitational strength weakens with distance. $$ \\frac{\\partial v_1}{\\partial R} < 0. $$ Gravitational Constant ( \\(G\\) ) : All velocities scale proportionally with \\(G\\) ( \\(v_1, v_2 \\propto \\sqrt{G}\\) ). Star Mass and Distance ( \\(M_s\\) , \\(R_s\\) ) : For \\(v_3\\) , a larger \\(M_s\\) or smaller \\(R_s\\) increases \\(v_{\\text{esc,s}}\\) , raising the total velocity. Conclusion The derivations reveal how \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) emerge from gravitational and energy principles, with parameters \\(M\\) , \\(R\\) , \\(M_s\\) , and \\(R_s\\) dictating their magnitudes. These dependencies are critical for tailoring space missions to specific celestial environments. Escape Velocities and Cosmic Velocities: Calculations for Celestial Bodies Introduction This section computes the first ( \\(v_1\\) ), second ( \\(v_2\\) ), and third ( \\(v_3\\) ) cosmic velocities for Earth, Mars, and Jupiter, using their physical parameters and gravitational principles. 1. Celestial Body Data Key parameters for calculations: Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) , \\(R_s = 1.496 \\times 10^{11} \\, \\text{m}\\) . Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.390 \\times 10^6 \\, \\text{m}\\) , \\(R_s = 2.279 \\times 10^{11} \\, \\text{m}\\) . Jupiter : \\(M = 1.899 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) , \\(R_s = 7.785 \\times 10^{11} \\, \\text{m}\\) . Constants: \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) , \\(M_s = 1.989 \\times 10^{30} \\, \\text{kg}\\) . 2. Formulas First Cosmic Velocity : \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) . Second Cosmic Velocity : \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) . Third Cosmic Velocity : \\(v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2}\\) , where: \\(v_{\\text{orb}} = \\sqrt{\\frac{G M_s}{R_s}}\\) , \\(v_{\\text{esc,s}} = \\sqrt{\\frac{2 G M_s}{R_s}}\\) . 3. Calculation Plan Compute \\(v_1\\) and \\(v_2\\) for each body using \\(M\\) and \\(R\\) . Compute \\(v_{\\text{orb}}\\) and \\(v_{\\text{esc,s}}\\) for \\(v_3\\) using \\(M_s\\) and \\(R_s\\) . Combine results to calculate \\(v_3\\) . Convert results to \\(\\text{km/s}\\) and verify against known values. Escape Velocities and Cosmic Velocities: Importance in Space Exploration Introduction Cosmic velocities are fundamental to space exploration, defining the energy thresholds required for orbiting, escaping planetary gravity, and venturing beyond star systems. These velocities enable humanity to overcome gravitational barriers and achieve significant milestones in space travel. 1. First Cosmic Velocity: Launching Satellites The first cosmic velocity ensures a spacecraft achieves a stable orbit, crucial for deploying satellites and maintaining orbital infrastructure. Examples include: - Sputnik 1 (1957) : The first artificial satellite, which achieved low Earth orbit by reaching this velocity. - International Space Station (ISS) : Orbits Earth at approximately \\(7.66 \\, \\text{km/s}\\) , demonstrating the practical application of this velocity. 2. Second Cosmic Velocity: Escaping Planetary Gravity The second cosmic velocity allows spacecraft to escape a planet\u2019s gravitational pull, enabling interplanetary missions. Examples include: - Apollo 11 (1969) : Surpassed Earth\u2019s escape velocity to reach the Moon. - Mars Curiosity Rover (2011) : Exceeded Earth\u2019s escape velocity to embark on its journey to Mars. 3. Third Cosmic Velocity: Interstellar Exploration The third cosmic velocity is essential for escaping a star system, paving the way for interstellar travel. Notable examples: - Voyager 1 (1977) : Exceeded the Solar System\u2019s escape velocity, now traveling in interstellar space. - New Horizons (2006) : Approached this velocity with gravity assists, enabling its journey to Pluto and beyond. Conclusion Cosmic velocities are pivotal in space exploration, enabling orbital operations, planetary missions, and interstellar ambitions. Real-world missions like Sputnik, Apollo, and Voyager exemplify their critical role in advancing humanity\u2019s reach into the cosmos. Codes and Plots Detailed Cosmic Velocities for Earth, Mars, and Jupiter import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 M_sun = 1.989e30 # Data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'distance_sun': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6, 'distance_sun': 2.279e11}, 'Jupiter': {'mass': 1.899e27, 'radius': 6.991e7, 'distance_sun': 7.785e11} } # Calculate velocities def calculate_cosmic_velocities(M, R, R_s): v1 = np.sqrt(G * M / R) / 1000 v2 = np.sqrt(2 * G * M / R) / 1000 v_orb = np.sqrt(G * M_sun / R_s) / 1000 v_esc_s = np.sqrt(2 * G * M_sun / R_s) / 1000 v_excess = v_esc_s - v_orb v3 = np.sqrt(v2**2 + v_excess**2) return v1, v2, v3 velocities = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['distance_sun']) velocities[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Individual Subplots fig, axs = plt.subplots(1, 3, figsize=(18, 5), sharey=True) for i, (body, data) in enumerate(velocities.items()): axs[i].bar(['$v_1$', '$v_2$', '$v_3$'], [data['v1'], data['v2'], data['v3']], color=['skyblue', 'salmon', 'lightgreen']) axs[i].set_title(f'{body}') axs[i].set_ylabel('Velocity (km/s)' if i == 0 else '') axs[i].grid(True, linestyle='--', alpha=0.7) for j, v in enumerate([data['v1'], data['v2'], data['v3']]): axs[i].text(j, v + 0.5, f'{v:.2f}', ha='center', va='bottom') plt.suptitle('Detailed Cosmic Velocities by Celestial Body', fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() Colab Colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities-definitions-and-physical-meaning","text":"","title":"Escape Velocities and Cosmic Velocities: Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The study of cosmic velocities is foundational to celestial mechanics and space exploration. These velocities\u2014first, second, and third\u2014represent critical thresholds for overcoming gravitational forces at various scales. This section defines each velocity, derives their physical significance, and elucidates their roles in gravitational dynamics.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity , denoted \\(v_1\\) , is the minimum speed required for an object to maintain a circular orbit around a celestial body at its surface. It arises from balancing the centripetal force required for circular motion with the gravitational force exerted by the body. The gravitational force on an object of mass \\(m\\) at the surface of a body with mass \\(M\\) and radius \\(R\\) is given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{R^2}, $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). For circular motion, the centripetal force is provided by gravity, such that: $$ F_c = \\frac{m v_1^2}{R} = F_g. $$ Equating these forces: $$ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2}. $$ Canceling \\(m\\) (assuming \\(m \\neq 0\\) ) and simplifying: $$ v_1^2 = \\frac{G M}{R}. $$ Thus, the first cosmic velocity is: $$ v_1 = \\sqrt{\\frac{G M}{R}}. $$","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-meaning","text":"The velocity \\(v_1\\) represents the threshold where an object\u2019s kinetic energy per unit mass, \\(\\frac{1}{2} v_1^2\\) , equals the gravitational potential energy per unit mass at the surface, adjusted for circular motion. For Earth ( \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) ), \\(v_1 \\approx 7.91 \\, \\text{km/s}\\) . This speed enables satellites to orbit without escaping or falling back.","title":"Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity , denoted \\(v_2\\) , is the minimum speed required to escape a celestial body\u2019s gravitational influence entirely, assuming no atmospheric drag or external forces. It corresponds to the point where the total mechanical energy (kinetic plus potential) becomes zero at infinity. The gravitational potential energy at distance \\(r\\) from the center of mass is: $$ U = -\\frac{G M m}{r}. $$ At the surface ( \\(r = R\\) ), the potential energy is \\(-\\frac{G M m}{R}\\) . To escape, the kinetic energy at launch must equal the magnitude of this potential energy: $$ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R}. $$ Canceling \\(m\\) and solving: $$ v_2^2 = \\frac{2 G M}{R}, $$ $$ v_2 = \\sqrt{\\frac{2 G M}{R}}. $$ Notably, comparing \\(v_2\\) to \\(v_1\\) : $$ v_2 = \\sqrt{2} \\cdot v_1, $$ since \\(\\frac{2 G M}{R} = 2 \\cdot \\frac{G M}{R}\\) .","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-meaning_1","text":"The escape velocity \\(v_2\\) signifies the condition where an object\u2019s kinetic energy, \\(\\frac{1}{2} v_2^2 = \\frac{G M}{R}\\) , exactly cancels the negative potential energy, allowing it to reach infinity with zero residual speed. For Earth, \\(v_2 \\approx 11.19 \\, \\text{km/s}\\) , critical for lunar or interplanetary missions.","title":"Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-system-escape-velocity","text":"The third cosmic velocity , denoted \\(v_3\\) , is the speed required to escape the gravitational influence of a star system (e.g., the Solar System) from a given starting point, such as a planet\u2019s surface. It builds on \\(v_2\\) by accounting for the star\u2019s gravitational pull (e.g., the Sun). Consider an object escaping Earth\u2019s gravity ( \\(v_2\\) ) while orbiting the Sun (mass \\(M_s\\) , distance from Sun \\(R_s\\) ). The total energy in the heliocentric frame must be zero or positive to escape the Solar System. The energy equation at Earth\u2019s orbit is complex, but an approximation from Earth\u2019s surface involves: - Earth escape: \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) , - Additional velocity to escape the Sun\u2019s gravity from Earth\u2019s orbital radius. The Sun\u2019s potential at Earth\u2019s distance ( \\(R_s \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) ) is: $$ U_s = -\\frac{G M_s m}{R_s}. $$ Earth\u2019s orbital velocity around the Sun is: $$ v_{\\text{orb}} = \\sqrt{\\frac{G M_s}{R_s}} \\approx 29.78 \\, \\text{km/s}. $$ The velocity to escape the Sun from Earth\u2019s orbit is: $$ v_{\\text{esc,s}} = \\sqrt{2} \\cdot v_{\\text{orb}} \\approx 42.1 \\, \\text{km/s}. $$ The third cosmic velocity combines Earth escape and Solar escape, approximated as: $$ v_3 \\approx \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2}. $$ For Earth, \\(v_3 \\approx 16.6 \\, \\text{km/s}\\) from the surface, though exact values depend on trajectory.","title":"3. Third Cosmic Velocity (System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-meaning_2","text":"The velocity \\(v_3\\) reflects the energy needed to overcome both planetary and stellar gravitational wells, enabling interstellar travel. It underscores the immense challenge of escaping a star system, as the kinetic energy must satisfy: $$ \\frac{1}{2} m v_3^2 \\geq \\frac{G M m}{R} + \\frac{G M_s m}{R_s}. $$","title":"Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"The first, second, and third cosmic velocities\u2014 \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) \u2014define the energetic thresholds for orbiting, escaping a planet, and escaping a star system, respectively. Their derivations from gravitational and kinetic principles highlight their universal applicability in space exploration.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities-mathematical-derivations","text":"","title":"Escape Velocities and Cosmic Velocities: Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction_1","text":"The cosmic velocities\u2014first ( \\(v_1\\) ), second ( \\(v_2\\) ), and third ( \\(v_3\\) )\u2014are derived from fundamental principles of classical mechanics, specifically Newton\u2019s law of gravitation and the conservation of mechanical energy. This section identifies the key equations, provides rigorous step-by-step derivations, lists the parameters involved, and analyzes their influence on the resulting velocities.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-equations","text":"The foundational equations for the cosmic velocities are: - First cosmic velocity (orbital velocity): $$ v_1 = \\sqrt{\\frac{G M}{R}} $$ - Second cosmic velocity (escape velocity): $$ v_2 = \\sqrt{\\frac{2 G M}{R}} $$ - Third cosmic velocity (system escape velocity): $$ v_3 \\approx \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2} $$ Here, \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(R\\) is its radius, \\(M_s\\) is the star\u2019s mass, \\(R_s\\) is the distance from the star, \\(v_{\\text{esc,s}}\\) is the escape velocity from the star, and \\(v_{\\text{orb}}\\) is the orbital velocity around the star.","title":"Key Equations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-derivation-of-the-first-cosmic-velocity-v_1","text":"The first cosmic velocity is the speed required for an object of mass \\(m\\) to maintain a circular orbit at the surface of a celestial body (radius \\(R\\) , mass \\(M\\) ).","title":"1. Derivation of the First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-by-step-derivation","text":"Newton\u2019s Law of Gravitation : The gravitational force provides the centripetal force: $$ F_g = \\frac{G M m}{R^2}. $$ Centripetal Force for Circular Motion : For an object in circular orbit at radius \\(R\\) : $$ F_c = \\frac{m v_1^2}{R}. $$ Equate Forces : Since \\(F_g\\) supplies \\(F_c\\) : $$ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2}. $$ Simplify : Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and multiply both sides by \\(R\\) : $$ v_1^2 = \\frac{G M}{R}. $$ Solve for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{G M}{R}}. $$","title":"Step-by-Step Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-insight","text":"The term \\(\\frac{G M}{R}\\) is the gravitational parameter divided by distance, representing the specific energy required for circular motion.","title":"Physical Insight"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivation-of-the-second-cosmic-velocity-v_2","text":"The second cosmic velocity is the minimum speed to escape a celestial body\u2019s gravitational field, reaching infinity with zero residual velocity.","title":"2. Derivation of the Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-by-step-derivation_1","text":"Conservation of Energy : Total mechanical energy (kinetic + potential) is conserved. At the surface: Kinetic energy: $$ K = \\frac{1}{2} m v_2^2 $$ Potential energy: $$ U = -\\frac{G M m}{R} $$ Energy at Infinity : For escape, total energy at \\(r \\to \\infty\\) is zero (where \\(U = 0\\) ): $$ E_{\\text{total}} = K + U = 0. $$ Set Initial Energy : At the surface ( \\(r = R\\) ): $$ \\frac{1}{2} m v_2^2 - \\frac{G M m}{R} = 0. $$ Simplify : Cancel \\(m\\) and solve: $$ \\frac{1}{2} v_2^2 = \\frac{G M}{R}, $$ $$ v_2^2 = \\frac{2 G M}{R}. $$ Solve for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2 G M}{R}}. $$","title":"Step-by-Step Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#relation-to-v_1","text":"Since \\(v_1^2 = \\frac{G M}{R}\\) , we find: $$ v_2^2 = 2 v_1^2, $$ $$ v_2 = \\sqrt{2} \\cdot v_1. $$","title":"Relation to \\(v_1\\):"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-insight_1","text":"The factor of 2 arises because escape requires doubling the kinetic energy relative to orbiting, overcoming the full potential well.","title":"Physical Insight"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-derivation-of-the-third-cosmic-velocity-v_3","text":"The third cosmic velocity is the speed to escape a star system (e.g., the Sun) from a planet\u2019s surface, combining planetary and stellar escape.","title":"3. Derivation of the Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-by-step-derivation_2","text":"Planetary Escape : From the planet (e.g., Earth), use \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2 G M}{R}}. $$ Stellar Potential : At the planet\u2019s distance from the star ( \\(R_s\\) , \\(M_s\\) ): $$ U_s = -\\frac{G M_s m}{R_s}. $$ Orbital Velocity Around Star : The planet\u2019s orbital speed: $$ v_{\\text{orb}} = \\sqrt{\\frac{G M_s}{R_s}}. $$ Escape Velocity from Star : From the planet\u2019s orbit: $$ v_{\\text{esc,s}} = \\sqrt{\\frac{2 G M_s}{R_s}} = \\sqrt{2} \\cdot v_{\\text{orb}}. $$ Excess Velocity : The additional speed beyond \\(v_{\\text{orb}}\\) to escape the star: $$ v_{\\text{excess}} = v_{\\text{esc,s}} - v_{\\text{orb}}. $$ Total Velocity : Combine velocities vectorially (approximate): $$ v_3^2 = v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2, $$ $$ v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2}. $$","title":"Step-by-Step Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#physical-insight_2","text":"The derivation accounts for two gravitational potentials, requiring a velocity composition that exceeds both local and system-wide escape thresholds.","title":"Physical Insight"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-involved","text":"Gravitational Constant ( \\(G\\) ) : Universal constant, \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) . Mass of Celestial Body ( \\(M\\) ) : Mass of the planet or star. Radius of Celestial Body ( \\(R\\) ) : Distance from the center to the surface. Mass of Star ( \\(M_s\\) ) : For \\(v_3\\) , the star\u2019s mass. Distance from Star ( \\(R_s\\) ) : For \\(v_3\\) , the orbital radius.","title":"Parameters Involved"},{"location":"1%20Physics/2%20Gravity/Problem_2/#influence-of-parameters","text":"Mass ( \\(M\\) ) : Velocities \\(v_1\\) and \\(v_2\\) increase with \\(M\\) ( \\(v_1, v_2 \\propto \\sqrt{M}\\) ). For \\(v_3\\) , both \\(M\\) and \\(M_s\\) amplify the required speed. $$ \\frac{\\partial v_1}{\\partial M} > 0. $$ Radius ( \\(R\\) ) : Velocities \\(v_1\\) and \\(v_2\\) decrease with \\(R\\) ( \\(v_1, v_2 \\propto \\frac{1}{\\sqrt{R}}\\) ), as gravitational strength weakens with distance. $$ \\frac{\\partial v_1}{\\partial R} < 0. $$ Gravitational Constant ( \\(G\\) ) : All velocities scale proportionally with \\(G\\) ( \\(v_1, v_2 \\propto \\sqrt{G}\\) ). Star Mass and Distance ( \\(M_s\\) , \\(R_s\\) ) : For \\(v_3\\) , a larger \\(M_s\\) or smaller \\(R_s\\) increases \\(v_{\\text{esc,s}}\\) , raising the total velocity.","title":"Influence of Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion_1","text":"The derivations reveal how \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) emerge from gravitational and energy principles, with parameters \\(M\\) , \\(R\\) , \\(M_s\\) , and \\(R_s\\) dictating their magnitudes. These dependencies are critical for tailoring space missions to specific celestial environments.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities-calculations-for-celestial-bodies","text":"","title":"Escape Velocities and Cosmic Velocities: Calculations for Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction_2","text":"This section computes the first ( \\(v_1\\) ), second ( \\(v_2\\) ), and third ( \\(v_3\\) ) cosmic velocities for Earth, Mars, and Jupiter, using their physical parameters and gravitational principles.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-celestial-body-data","text":"Key parameters for calculations: Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) , \\(R_s = 1.496 \\times 10^{11} \\, \\text{m}\\) . Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.390 \\times 10^6 \\, \\text{m}\\) , \\(R_s = 2.279 \\times 10^{11} \\, \\text{m}\\) . Jupiter : \\(M = 1.899 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) , \\(R_s = 7.785 \\times 10^{11} \\, \\text{m}\\) . Constants: \\(G = 6.674 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) , \\(M_s = 1.989 \\times 10^{30} \\, \\text{kg}\\) .","title":"1. Celestial Body Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-formulas","text":"First Cosmic Velocity : \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) . Second Cosmic Velocity : \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) . Third Cosmic Velocity : \\(v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,s}} - v_{\\text{orb}})^2}\\) , where: \\(v_{\\text{orb}} = \\sqrt{\\frac{G M_s}{R_s}}\\) , \\(v_{\\text{esc,s}} = \\sqrt{\\frac{2 G M_s}{R_s}}\\) .","title":"2. Formulas"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculation-plan","text":"Compute \\(v_1\\) and \\(v_2\\) for each body using \\(M\\) and \\(R\\) . Compute \\(v_{\\text{orb}}\\) and \\(v_{\\text{esc,s}}\\) for \\(v_3\\) using \\(M_s\\) and \\(R_s\\) . Combine results to calculate \\(v_3\\) . Convert results to \\(\\text{km/s}\\) and verify against known values.","title":"3. Calculation Plan"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities-importance-in-space-exploration","text":"","title":"Escape Velocities and Cosmic Velocities: Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction_3","text":"Cosmic velocities are fundamental to space exploration, defining the energy thresholds required for orbiting, escaping planetary gravity, and venturing beyond star systems. These velocities enable humanity to overcome gravitational barriers and achieve significant milestones in space travel.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-launching-satellites","text":"The first cosmic velocity ensures a spacecraft achieves a stable orbit, crucial for deploying satellites and maintaining orbital infrastructure. Examples include: - Sputnik 1 (1957) : The first artificial satellite, which achieved low Earth orbit by reaching this velocity. - International Space Station (ISS) : Orbits Earth at approximately \\(7.66 \\, \\text{km/s}\\) , demonstrating the practical application of this velocity.","title":"1. First Cosmic Velocity: Launching Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escaping-planetary-gravity","text":"The second cosmic velocity allows spacecraft to escape a planet\u2019s gravitational pull, enabling interplanetary missions. Examples include: - Apollo 11 (1969) : Surpassed Earth\u2019s escape velocity to reach the Moon. - Mars Curiosity Rover (2011) : Exceeded Earth\u2019s escape velocity to embark on its journey to Mars.","title":"2. Second Cosmic Velocity: Escaping Planetary Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-interstellar-exploration","text":"The third cosmic velocity is essential for escaping a star system, paving the way for interstellar travel. Notable examples: - Voyager 1 (1977) : Exceeded the Solar System\u2019s escape velocity, now traveling in interstellar space. - New Horizons (2006) : Approached this velocity with gravity assists, enabling its journey to Pluto and beyond.","title":"3. Third Cosmic Velocity: Interstellar Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion_2","text":"Cosmic velocities are pivotal in space exploration, enabling orbital operations, planetary missions, and interstellar ambitions. Real-world missions like Sputnik, Apollo, and Voyager exemplify their critical role in advancing humanity\u2019s reach into the cosmos.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#codes-and-plots","text":"","title":"Codes and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#detailed-cosmic-velocities-for-earth-mars-and-jupiter","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 M_sun = 1.989e30 # Data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'distance_sun': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3.390e6, 'distance_sun': 2.279e11}, 'Jupiter': {'mass': 1.899e27, 'radius': 6.991e7, 'distance_sun': 7.785e11} } # Calculate velocities def calculate_cosmic_velocities(M, R, R_s): v1 = np.sqrt(G * M / R) / 1000 v2 = np.sqrt(2 * G * M / R) / 1000 v_orb = np.sqrt(G * M_sun / R_s) / 1000 v_esc_s = np.sqrt(2 * G * M_sun / R_s) / 1000 v_excess = v_esc_s - v_orb v3 = np.sqrt(v2**2 + v_excess**2) return v1, v2, v3 velocities = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['distance_sun']) velocities[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Individual Subplots fig, axs = plt.subplots(1, 3, figsize=(18, 5), sharey=True) for i, (body, data) in enumerate(velocities.items()): axs[i].bar(['$v_1$', '$v_2$', '$v_3$'], [data['v1'], data['v2'], data['v3']], color=['skyblue', 'salmon', 'lightgreen']) axs[i].set_title(f'{body}') axs[i].set_ylabel('Velocity (km/s)' if i == 0 else '') axs[i].grid(True, linestyle='--', alpha=0.7) for j, v in enumerate([data['v1'], data['v2'], data['v3']]): axs[i].text(j, v + 0.5, f'{v:.2f}', ha='center', va='bottom') plt.suptitle('Detailed Cosmic Velocities by Celestial Body', fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"Detailed Cosmic Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Orbital Mechanics Simulator Orbital Mechanics Simulator Theoretical Analysis of Payload Trajectories Near Earth This section outlines the theoretical framework for analyzing payload trajectories near Earth, using Newton's Law of Gravitation, Kepler's Laws, and energy considerations. We assume a two-body problem with Earth as the dominant gravitational influence, neglecting atmospheric drag and other perturbations. 1. Derivation of Equations of Motion The motion of a payload near Earth is governed by Newton's Law of Gravitation: \\[ \\mathbf{F} = -\\frac{G M m}{|\\mathbf{r}|^3} \\mathbf{r}, \\] where \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass, and \\(\\mathbf{r}\\) is the position vector. Applying Newton's Second Law, \\(\\mathbf{F} = m \\mathbf{a}\\) , yields: \\[ \\ddot{\\mathbf{r}} = -\\frac{G M}{|\\mathbf{r}|^3} \\mathbf{r}. \\] Defining \\(\\mu = G M\\) , the equation becomes: \\[ \\ddot{\\mathbf{r}} = -\\frac{\\mu}{r^3} \\mathbf{r}, \\] where \\(r = |\\mathbf{r}|\\) . In polar coordinates, the radial and tangential components are: \\[ \\ddot{r} - r \\dot{\\theta}^2 = -\\frac{\\mu}{r^2}, \\quad r \\ddot{\\theta} + 2 \\dot{r} \\dot{\\theta} = 0. \\] The second equation implies conservation of angular momentum, \\(r^2 \\dot{\\theta} = h\\) , where \\(h\\) is constant. 2. Application of Kepler's Laws Kepler's Laws describe orbital characteristics: First Law : Orbits are conic sections with Earth at one focus. The orbit equation is: \\[ r = \\frac{a (1 - e^2)}{1 + e \\cos \\theta}, \\] where \\(a\\) is the semi-major axis, \\(e\\) is the eccentricity, and \\(\\theta\\) is the true anomaly. Second Law : Equal areas are swept in equal times, implying constant areal velocity: \\[ \\frac{dA}{dt} = \\frac{1}{2} r^2 \\dot{\\theta} = \\frac{h}{2}. \\] Third Law : For elliptical orbits, the orbital period \\(T\\) is: \\[ T^2 = \\frac{4 \\pi^2}{\\mu} a^3. \\] 3. Identification of Trajectory Types The trajectory type depends on the specific mechanical energy \\(\\epsilon\\) : \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r}, \\] where \\(v\\) is the speed. Trajectories are classified as: Elliptical ( \\(\\epsilon < 0\\) ) : Bound orbit, with \\(a = -\\frac{\\mu}{2 \\epsilon}\\) . Parabolic ( \\(\\epsilon = 0\\) ) : Escape trajectory, \\(v = \\sqrt{\\frac{2 \\mu}{r}}\\) . Hyperbolic ( \\(\\epsilon > 0\\) ) : Unbound, with excess speed \\(v_\\infty = \\sqrt{2 \\epsilon}\\) . Eccentricity \\(e\\) is related to \\(\\epsilon\\) and angular momentum \\(h\\) : \\[ e = \\sqrt{1 + \\frac{2 \\epsilon h^2}{\\mu^2}}. \\] 4. Definition of Initial Conditions The trajectory is determined by the initial state vector \\((\\mathbf{r}_0, \\mathbf{v}_0)\\) : Position : \\(\\mathbf{r}_0 = (x_0, y_0, z_0)\\) or altitude \\(h\\) , with \\(r_0 = R_E + h\\) . Velocity : \\(\\mathbf{v}_0 = (v_x, v_y, v_z)\\) or speed \\(v_0\\) and flight path angle \\(\\gamma\\) . Altitude : \\(h\\) determines \\(r_0\\) , with \\(R_E \\approx 6,371 \\, \\text{km}\\) . Specific angular momentum is: \\[ \\mathbf{h} = \\mathbf{r}_0 \\times \\mathbf{v}_0. \\] Numerical Analysis of Payload Trajectory This section performs a numerical analysis to propagate the trajectory of a payload released near Earth, using the numerical methods outlined previously. We compute example calculations for a specific case with initial conditions \\(r_0 = 6,571 \\, \\text{km}\\) (corresponding to an altitude \\(h \\approx 200 \\, \\text{km}\\) above Earth's mean radius \\(R_E \\approx 6,371 \\, \\text{km}\\) ) and initial speed \\(v_0 = 7.8 \\, \\text{km/s}\\) . The analysis illustrates the application of the numerical integration scheme to determine the payload's path, providing a foundation for subsequent simulations and visualizations. Example Trajectory Propagation To propagate the trajectory, we solve the two-body equation of motion: \\[ \\ddot{\\mathbf{r}} = -\\frac{\\mu}{r^3} \\mathbf{r}, \\] where \\(\\mu \\approx 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2}\\) is Earth's gravitational parameter, and \\(r = |\\mathbf{r}|\\) . We use the Runge-Kutta method of order 4 (RK4) to integrate the system, converted to first-order ODEs with state vector \\(\\mathbf{y} = [\\mathbf{r}, \\mathbf{v}]^T\\) : \\[ \\frac{d\\mathbf{y}}{dt} = \\begin{bmatrix} \\mathbf{v} \\\\ -\\frac{\\mu}{r^3} \\mathbf{r} \\end{bmatrix}. \\] RK4 Method: General Example To illustrate the Runge-Kutta 4th-order (RK4) method used in trajectory propagation, we first demonstrate it on a simpler differential equation before applying it to the two-body problem. Consider the first-order ODE: \\[ \\frac{dy}{dt} = f(t, y) = y - t^2 + 1, \\quad y(0) = 0.5, \\] with a step size \\( h = 0.2 \\) . We compute the next state \\( y_1 \\) at \\( t = 0.2 \\) . Step 1: Compute Intermediate Increments The RK4 method calculates four increments: \\[ \\begin{aligned} k_1 &= f(t_0, y_0) = f(0, 0.5) = 0.5 - 0^2 + 1 = 1.5, \\\\ k_2 &= f\\left(t_0 + \\frac{h}{2}, y_0 + \\frac{h}{2} k_1\\right) = f(0.1, 0.5 + 0.1 \\cdot 1.5) = f(0.1, 0.575) \\\\ &= 0.575 - 0.1^2 + 1 = 0.575 - 0.01 + 1 = 1.565, \\\\ k_3 &= f\\left(t_0 + \\frac{h}{2}, y_0 + \\frac{h}{2} k_2\\right) = f(0.1, 0.5 + 0.1 \\cdot 1.565) = f(0.1, 0.57825) \\\\ &= 0.57825 - 0.01 + 1 = 1.56825, \\\\ k_4 &= f(t_0 + h, y_0 + h \\cdot k_3) = f(0.2, 0.5 + 0.2 \\cdot 1.56825) = f(0.2, 0.81365) \\\\ &= 0.81365 - 0.04 + 1 = 1.77365. \\end{aligned} \\] Step 2: Update the State The next state is computed as: \\[ \\begin{aligned} y_1 &= y_0 + \\frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\\\ &= 0.5 + \\frac{0.2}{6} (1.5 + 2 \\cdot 1.565 + 2 \\cdot 1.56825 + 1.77365) \\\\ &= 0.5 + \\frac{0.2}{6} (1.5 + 3.13 + 3.1365 + 1.77365) \\\\ &= 0.5 + \\frac{0.2}{6} \\cdot 9.54015 \\approx 0.5 + 0.318005 \\\\ &= 0.818. \\end{aligned} \\] Thus, \\( y(0.2) \\approx 0.818 \\) . This example clarifies the RK4 process, which we apply to the two-body problem in the following steps. Initial Conditions Setup Assume the payload is released at \\(t = 0\\) with position \\(\\mathbf{r}_0 = [r_0, 0, 0]^T = [6,571 \\times 10^3, 0, 0]^T \\, \\text{m}\\) in an Earth-centered inertial frame, and velocity \\(\\mathbf{v}_0 = [0, v_0, 0]^T = [0, 7.8 \\times 10^3, 0]^T \\, \\text{m/s}\\) , corresponding to a tangential release (flight path angle \\(\\gamma = 0^\\circ\\) ) in the \\(xy\\) -plane. The initial state vector is: \\[ \\mathbf{y}_0 = [6,571 \\times 10^3, 0, 0, 0, 7.8 \\times 10^3, 0]^T. \\] We first compute the specific mechanical energy to classify the trajectory: \\[ \\epsilon = \\frac{v_0^2}{2} - \\frac{\\mu}{r_0}. \\] Substituting \\(v_0 = 7.8 \\times 10^3 \\, \\text{m/s}\\) , \\(r_0 = 6,571 \\times 10^3 \\, \\text{m}\\) , and \\(\\mu = 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2}\\) : \\[ \\frac{v_0^2}{2} = \\frac{(7.8 \\times 10^3)^2}{2} = \\frac{60.84 \\times 10^6}{2} = 30.42 \\times 10^6 \\, \\text{J/kg}, \\] \\[ \\frac{\\mu}{r_0} = \\frac{3.986 \\times 10^{14}}{6.571 \\times 10^6} \\approx 60.66 \\times 10^6 \\, \\text{J/kg}, \\] \\[ \\epsilon = 30.42 \\times 10^6 - 60.66 \\times 10^6 = -30.24 \\times 10^6 \\, \\text{J/kg}. \\] Since \\(\\epsilon < 0\\) , the trajectory is elliptical, indicating a bound orbit. The semi-major axis is: \\[ a = -\\frac{\\mu}{2 \\epsilon} = -\\frac{3.986 \\times 10^{14}}{2 \\times (-30.24 \\times 10^6)} \\approx 6.59 \\times 10^6 \\, \\text{m} = 6,590 \\, \\text{km}. \\] Numerical Integration Step Using RK4 with a time step \\(\\Delta t = 1 \\, \\text{s}\\) , we compute one integration step to illustrate the process. At \\(t = 0\\) , evaluate the derivative \\(\\frac{d\\mathbf{y}}{dt}\\) : Position derivative: \\(\\dot{\\mathbf{r}}_0 = \\mathbf{v}_0 = [0, 7.8 \\times 10^3, 0]^T \\, \\text{m/s}\\) . Velocity derivative: \\(\\dot{\\mathbf{v}}_0 = -\\frac{\\mu}{r_0^3} \\mathbf{r}_0\\) , where \\(r_0 = 6,571 \\times 10^3 \\, \\text{m}\\) , so: \\[ r_0^3 = (6.571 \\times 10^6)^3 \\approx 2.835 \\times 10^{20} \\, \\text{m}^3, \\] \\[ \\frac{\\mu}{r_0^3} = \\frac{3.986 \\times 10^{14}}{2.835 \\times 10^{20}} \\approx 1.406 \\times 10^{-6} \\, \\text{s}^{-2}, \\] \\[ \\dot{\\mathbf{v}}_0 = -1.406 \\times 10^{-6} \\cdot [6.571 \\times 10^6, 0, 0]^T \\approx [-9.24, 0, 0]^T \\, \\text{m/s}^2. \\] Thus, \\(\\frac{d\\mathbf{y}_0}{dt} = [0, 7.8 \\times 10^3, 0, -9.24, 0, 0]^T\\) . The RK4 method computes increments \\(\\mathbf{k}_1, \\mathbf{k}_2, \\mathbf{k}_3, \\mathbf{k}_4\\) based on this and intermediate states, updating \\(\\mathbf{y}_1 = \\mathbf{y}_0 + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\\) . For brevity, we note that this step yields a new position and velocity at \\(t = 1 \\, \\text{s}\\) , slightly adjusted from \\(\\mathbf{y}_0\\) due to gravitational acceleration. Verification To ensure accuracy, we check the specific angular momentum: \\[ \\mathbf{h}_0 = \\mathbf{r}_0 \\times \\mathbf{v}_0 = \\begin{vmatrix} \\hat{\\mathbf{i}} & \\hat{\\mathbf{j}} & \\hat{\\mathbf{k}} \\\\ 6.571 \\times 10^6 & 0 & 0 \\\\ 0 & 7.8 \\times 10^3 & 0 \\end{vmatrix} = (6.571 \\times 10^6 \\cdot 7.8 \\times 10^3) \\hat{\\mathbf{k}} \\approx 5.125 \\times 10^{10} \\, \\hat{\\mathbf{k}} \\, \\text{m}^2 \\text{s}^{-1}. \\] The magnitude \\(h = 5.125 \\times 10^{10} \\, \\text{m}^2 \\text{s}^{-1}\\) should remain constant, verifiable at subsequent time steps. This confirms the trajectory lies in the \\(xy\\) -plane, consistent with our planar assumption. Applications and Contextual Analysis of Payload Trajectories This section explores practical implications of payload trajectories, including orbital insertion, reentry, and escape scenarios, with applications in satellite deployment, mission planning, and planetary exploration. 1. Trajectories and Orbital Insertion For circular orbits, the required velocity is: \\[ v_c = \\sqrt{\\frac{\\mu}{r}}. \\] For elliptical orbits, the velocity satisfies the vis-viva equation: \\[ v = \\sqrt{\\mu \\left( \\frac{2}{r} - \\frac{1}{a} \\right)}. \\] Precise control of \\(\\mathbf{v}_0\\) ensures the desired orbit, minimizing risks of unintended trajectories. 2. Trajectories and Reentry Processes Reentry dynamics depend on the entry angle \\(\\gamma\\) and velocity. A steep angle causes high heating, while a shallow angle risks skipping off the atmosphere. Escape or bound trajectories are determined by \\(\\epsilon\\) . 3. Trajectories and Escape Scenarios Escape requires achieving escape velocity: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r_0}}. \\] For \\(v_0 > v_{\\text{esc}}\\) , the trajectory is hyperbolic, with excess speed: \\[ v_\\infty = \\sqrt{v_0^2 - \\frac{2\\mu}{r_0}}. \\] Escape trajectories are crucial for interplanetary missions. 4. Real-World Applications: Satellite Deployment Satellite deployment relies on precise trajectory control. For GEO, a transfer orbit requires: \\[ v_0 = \\sqrt{\\mu \\left( \\frac{2}{r_0} - \\frac{1}{a} \\right)}, \\] where \\(a\\) is the semi-major axis of the transfer orbit. 5. Implications for Space Mission Planning Trajectory analysis informs launch windows, fuel budgets, and risk assessments. Orbital elements derived from \\(\\mathbf{r}_0\\) and \\(\\mathbf{v}_0\\) guide mission feasibility and collision avoidance. 6. Planetary Exploration Contexts Interplanetary missions require hyperbolic escape trajectories. For flybys, periapsis distance and speed are determined by: \\[ r_p = \\frac{h^2}{\\mu (1 + e)}. \\] These principles apply to gravity assists and deep-space missions. Code and Plots Trajectories in a Gravitational Field with Filled Earth import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) if r < R_Earth: # Prevent orbits from going through Earth return [0, 0, 0, 0] a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) # Filter out points inside the Earth x, y_vals = y[0, :], y[1, :] r = np.sqrt(x**2 + y_vals**2) mask = r >= R_Earth x, y_vals = x[mask], y_vals[mask] return t[mask], np.array([x, y_vals]) # Plotting function def plot_orbits(trajectories, earth_radius=R_Earth): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), earth_radius, color='blue', alpha=0.5, label=\"Earth\") ax.add_artist(circle) # Plot trajectories colors = ['red', 'green', 'orange', 'purple', 'cyan', 'magenta'] for i, traj in enumerate(trajectories): if traj[1] is not None: x, y = traj[1][0, :], traj[1][1, :] ax.plot(x, y, label=f\"Trajectory {i+1}\", color=colors[i]) # Add labels and legend ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.legend() ax.grid(True) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.show() # Define initial conditions for multiple trajectories trajectories = [] # Circular orbit y0_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6))] trajectories.append(simulate_orbit(y0_circular, [0, 10000], 1)) # Elliptical orbit (slightly perturbed from circular) y0_elliptical = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.95] trajectories.append(simulate_orbit(y0_elliptical, [0, 10000], 1)) # Reentry trajectory (low velocity) y0_reentry = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.5] trajectories.append(simulate_orbit(y0_reentry, [0, 10000], 1)) # Escape trajectory (high velocity) - Limit the time span y0_escape = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.5] trajectories.append(simulate_orbit(y0_escape, [0, 5000], 1)) # Shorter time span # Partial orbit (70% completion before falling back) y0_partial = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.8] trajectories.append(simulate_orbit(y0_partial, [0, 10000], 1)) # New trajectory: slightly faster than circular orbit y0_faster_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.1] trajectories.append(simulate_orbit(y0_faster_circular, [0, 10000], 1)) # Plot all trajectories plot_orbits(trajectories) Trajectories in a Gravitational Field with Filled Earth import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) if r < R_Earth: # Prevent orbits from going through Earth return [0, 0, 0, 0] a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) # Filter out points inside the Earth x, y_vals = y[0, :], y[1, :] r = np.sqrt(x**2 + y_vals**2) mask = r >= R_Earth x, y_vals = x[mask], y_vals[mask] return t[mask], np.array([x, y_vals]) # Function to plot multiple trajectories def plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.5, label=\"Earth\") ax.add_artist(circle) colors = plt.cm.viridis(np.linspace(0, 1, len(initial_conditions_list))) for i, (x0, y0, vx0, vy0) in enumerate(initial_conditions_list): y0_initial = [x0, y0, vx0, vy0] t, y = simulate_orbit(y0_initial, [0, t_max], t_max / num_points) x, y_vals = y[0, :], y[1, :] ax.plot(x, y_vals, label=f\"Trajectory {i+1}\", color=colors[i]) # Add labels and legend ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.legend() ax.grid(True) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.show() # Define initial conditions initial_conditions_list = [ (R_Earth + 1e6, 0, 0, 9000), (R_Earth + 1e6, 0, 0, 9100), (R_Earth + 1e6, 0, 0, 9200), (R_Earth + 1e6, 0, 0, 9300), (R_Earth + 1e6, 0, 0, 9400), (R_Earth + 1e6, 0, 0, 9500), (R_Earth + 1e6, 0, 0, 9600), (R_Earth + 1e6, 0, 0, 9700), (R_Earth + 1e6, 0, 0, 9800), (R_Earth + 1e6, 0, 0, 9900), (R_Earth + 1e6, 0, 0, 10000), ] # Call the function plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000) Trajectories in a Gravitational Field with Filled Earth import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) return t, y # Function to plot multiple trajectories def plot_trajectories(initial_conditions_list, t_max=50000, num_points=100): # Reduced t_max and increased num_points fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.5, label=\"Earth\") ax.add_artist(circle) colors = plt.cm.viridis(np.linspace(0, 1, len(initial_conditions_list))) for i, (x0, y0, vx0, vy0) in enumerate(initial_conditions_list): y0_initial = [x0, y0, vx0, vy0] t, y = simulate_orbit(y0_initial, [0, t_max], t_max / num_points) x, y_vals = y[0, :], y[1, :] ax.plot(x, y_vals, label=f\"Trajectory {i+1}\", color=colors[i]) # Add labels and legend ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.legend() ax.grid(True) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.show() # Define initial conditions initial_conditions_list = [ (R_Earth + 1e6, 0, 0, 11000), # Starting velocity of 11000 m/s (R_Earth + 1e6, 0, 0, 11500), # Slightly higher velocity (R_Earth + 1e6, 0, 0, 12000), (R_Earth + 1e6, 0, 0, 12500), (R_Earth + 1e6, 0, 0, 13000), (R_Earth + 1e6, 0, 0, 13500), ] # Call the function plot_trajectories(initial_conditions_list, t_max=50000, num_points=100) Colab Colab","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-mechanics-simulator","text":"Orbital Mechanics Simulator","title":"Orbital Mechanics Simulator"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-analysis-of-payload-trajectories-near-earth","text":"This section outlines the theoretical framework for analyzing payload trajectories near Earth, using Newton's Law of Gravitation, Kepler's Laws, and energy considerations. We assume a two-body problem with Earth as the dominant gravitational influence, neglecting atmospheric drag and other perturbations.","title":"Theoretical Analysis of Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-derivation-of-equations-of-motion","text":"The motion of a payload near Earth is governed by Newton's Law of Gravitation: \\[ \\mathbf{F} = -\\frac{G M m}{|\\mathbf{r}|^3} \\mathbf{r}, \\] where \\(G\\) is the gravitational constant, \\(M\\) is Earth's mass, and \\(\\mathbf{r}\\) is the position vector. Applying Newton's Second Law, \\(\\mathbf{F} = m \\mathbf{a}\\) , yields: \\[ \\ddot{\\mathbf{r}} = -\\frac{G M}{|\\mathbf{r}|^3} \\mathbf{r}. \\] Defining \\(\\mu = G M\\) , the equation becomes: \\[ \\ddot{\\mathbf{r}} = -\\frac{\\mu}{r^3} \\mathbf{r}, \\] where \\(r = |\\mathbf{r}|\\) . In polar coordinates, the radial and tangential components are: \\[ \\ddot{r} - r \\dot{\\theta}^2 = -\\frac{\\mu}{r^2}, \\quad r \\ddot{\\theta} + 2 \\dot{r} \\dot{\\theta} = 0. \\] The second equation implies conservation of angular momentum, \\(r^2 \\dot{\\theta} = h\\) , where \\(h\\) is constant.","title":"1. Derivation of Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-application-of-keplers-laws","text":"Kepler's Laws describe orbital characteristics: First Law : Orbits are conic sections with Earth at one focus. The orbit equation is: \\[ r = \\frac{a (1 - e^2)}{1 + e \\cos \\theta}, \\] where \\(a\\) is the semi-major axis, \\(e\\) is the eccentricity, and \\(\\theta\\) is the true anomaly. Second Law : Equal areas are swept in equal times, implying constant areal velocity: \\[ \\frac{dA}{dt} = \\frac{1}{2} r^2 \\dot{\\theta} = \\frac{h}{2}. \\] Third Law : For elliptical orbits, the orbital period \\(T\\) is: \\[ T^2 = \\frac{4 \\pi^2}{\\mu} a^3. \\]","title":"2. Application of Kepler's Laws"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-identification-of-trajectory-types","text":"The trajectory type depends on the specific mechanical energy \\(\\epsilon\\) : \\[ \\epsilon = \\frac{v^2}{2} - \\frac{\\mu}{r}, \\] where \\(v\\) is the speed. Trajectories are classified as: Elliptical ( \\(\\epsilon < 0\\) ) : Bound orbit, with \\(a = -\\frac{\\mu}{2 \\epsilon}\\) . Parabolic ( \\(\\epsilon = 0\\) ) : Escape trajectory, \\(v = \\sqrt{\\frac{2 \\mu}{r}}\\) . Hyperbolic ( \\(\\epsilon > 0\\) ) : Unbound, with excess speed \\(v_\\infty = \\sqrt{2 \\epsilon}\\) . Eccentricity \\(e\\) is related to \\(\\epsilon\\) and angular momentum \\(h\\) : \\[ e = \\sqrt{1 + \\frac{2 \\epsilon h^2}{\\mu^2}}. \\]","title":"3. Identification of Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-definition-of-initial-conditions","text":"The trajectory is determined by the initial state vector \\((\\mathbf{r}_0, \\mathbf{v}_0)\\) : Position : \\(\\mathbf{r}_0 = (x_0, y_0, z_0)\\) or altitude \\(h\\) , with \\(r_0 = R_E + h\\) . Velocity : \\(\\mathbf{v}_0 = (v_x, v_y, v_z)\\) or speed \\(v_0\\) and flight path angle \\(\\gamma\\) . Altitude : \\(h\\) determines \\(r_0\\) , with \\(R_E \\approx 6,371 \\, \\text{km}\\) . Specific angular momentum is: \\[ \\mathbf{h} = \\mathbf{r}_0 \\times \\mathbf{v}_0. \\]","title":"4. Definition of Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-analysis-of-payload-trajectory","text":"This section performs a numerical analysis to propagate the trajectory of a payload released near Earth, using the numerical methods outlined previously. We compute example calculations for a specific case with initial conditions \\(r_0 = 6,571 \\, \\text{km}\\) (corresponding to an altitude \\(h \\approx 200 \\, \\text{km}\\) above Earth's mean radius \\(R_E \\approx 6,371 \\, \\text{km}\\) ) and initial speed \\(v_0 = 7.8 \\, \\text{km/s}\\) . The analysis illustrates the application of the numerical integration scheme to determine the payload's path, providing a foundation for subsequent simulations and visualizations.","title":"Numerical Analysis of Payload Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-trajectory-propagation","text":"To propagate the trajectory, we solve the two-body equation of motion: \\[ \\ddot{\\mathbf{r}} = -\\frac{\\mu}{r^3} \\mathbf{r}, \\] where \\(\\mu \\approx 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2}\\) is Earth's gravitational parameter, and \\(r = |\\mathbf{r}|\\) . We use the Runge-Kutta method of order 4 (RK4) to integrate the system, converted to first-order ODEs with state vector \\(\\mathbf{y} = [\\mathbf{r}, \\mathbf{v}]^T\\) : \\[ \\frac{d\\mathbf{y}}{dt} = \\begin{bmatrix} \\mathbf{v} \\\\ -\\frac{\\mu}{r^3} \\mathbf{r} \\end{bmatrix}. \\]","title":"Example Trajectory Propagation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#rk4-method-general-example","text":"To illustrate the Runge-Kutta 4th-order (RK4) method used in trajectory propagation, we first demonstrate it on a simpler differential equation before applying it to the two-body problem. Consider the first-order ODE: \\[ \\frac{dy}{dt} = f(t, y) = y - t^2 + 1, \\quad y(0) = 0.5, \\] with a step size \\( h = 0.2 \\) . We compute the next state \\( y_1 \\) at \\( t = 0.2 \\) .","title":"RK4 Method: General Example"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-1-compute-intermediate-increments","text":"The RK4 method calculates four increments: \\[ \\begin{aligned} k_1 &= f(t_0, y_0) = f(0, 0.5) = 0.5 - 0^2 + 1 = 1.5, \\\\ k_2 &= f\\left(t_0 + \\frac{h}{2}, y_0 + \\frac{h}{2} k_1\\right) = f(0.1, 0.5 + 0.1 \\cdot 1.5) = f(0.1, 0.575) \\\\ &= 0.575 - 0.1^2 + 1 = 0.575 - 0.01 + 1 = 1.565, \\\\ k_3 &= f\\left(t_0 + \\frac{h}{2}, y_0 + \\frac{h}{2} k_2\\right) = f(0.1, 0.5 + 0.1 \\cdot 1.565) = f(0.1, 0.57825) \\\\ &= 0.57825 - 0.01 + 1 = 1.56825, \\\\ k_4 &= f(t_0 + h, y_0 + h \\cdot k_3) = f(0.2, 0.5 + 0.2 \\cdot 1.56825) = f(0.2, 0.81365) \\\\ &= 0.81365 - 0.04 + 1 = 1.77365. \\end{aligned} \\]","title":"Step 1: Compute Intermediate Increments"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-2-update-the-state","text":"The next state is computed as: \\[ \\begin{aligned} y_1 &= y_0 + \\frac{h}{6} (k_1 + 2 k_2 + 2 k_3 + k_4) \\\\ &= 0.5 + \\frac{0.2}{6} (1.5 + 2 \\cdot 1.565 + 2 \\cdot 1.56825 + 1.77365) \\\\ &= 0.5 + \\frac{0.2}{6} (1.5 + 3.13 + 3.1365 + 1.77365) \\\\ &= 0.5 + \\frac{0.2}{6} \\cdot 9.54015 \\approx 0.5 + 0.318005 \\\\ &= 0.818. \\end{aligned} \\] Thus, \\( y(0.2) \\approx 0.818 \\) . This example clarifies the RK4 process, which we apply to the two-body problem in the following steps.","title":"Step 2: Update the State"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-setup","text":"Assume the payload is released at \\(t = 0\\) with position \\(\\mathbf{r}_0 = [r_0, 0, 0]^T = [6,571 \\times 10^3, 0, 0]^T \\, \\text{m}\\) in an Earth-centered inertial frame, and velocity \\(\\mathbf{v}_0 = [0, v_0, 0]^T = [0, 7.8 \\times 10^3, 0]^T \\, \\text{m/s}\\) , corresponding to a tangential release (flight path angle \\(\\gamma = 0^\\circ\\) ) in the \\(xy\\) -plane. The initial state vector is: \\[ \\mathbf{y}_0 = [6,571 \\times 10^3, 0, 0, 0, 7.8 \\times 10^3, 0]^T. \\] We first compute the specific mechanical energy to classify the trajectory: \\[ \\epsilon = \\frac{v_0^2}{2} - \\frac{\\mu}{r_0}. \\] Substituting \\(v_0 = 7.8 \\times 10^3 \\, \\text{m/s}\\) , \\(r_0 = 6,571 \\times 10^3 \\, \\text{m}\\) , and \\(\\mu = 3.986 \\times 10^{14} \\, \\text{m}^3 \\text{s}^{-2}\\) : \\[ \\frac{v_0^2}{2} = \\frac{(7.8 \\times 10^3)^2}{2} = \\frac{60.84 \\times 10^6}{2} = 30.42 \\times 10^6 \\, \\text{J/kg}, \\] \\[ \\frac{\\mu}{r_0} = \\frac{3.986 \\times 10^{14}}{6.571 \\times 10^6} \\approx 60.66 \\times 10^6 \\, \\text{J/kg}, \\] \\[ \\epsilon = 30.42 \\times 10^6 - 60.66 \\times 10^6 = -30.24 \\times 10^6 \\, \\text{J/kg}. \\] Since \\(\\epsilon < 0\\) , the trajectory is elliptical, indicating a bound orbit. The semi-major axis is: \\[ a = -\\frac{\\mu}{2 \\epsilon} = -\\frac{3.986 \\times 10^{14}}{2 \\times (-30.24 \\times 10^6)} \\approx 6.59 \\times 10^6 \\, \\text{m} = 6,590 \\, \\text{km}. \\]","title":"Initial Conditions Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-integration-step","text":"Using RK4 with a time step \\(\\Delta t = 1 \\, \\text{s}\\) , we compute one integration step to illustrate the process. At \\(t = 0\\) , evaluate the derivative \\(\\frac{d\\mathbf{y}}{dt}\\) : Position derivative: \\(\\dot{\\mathbf{r}}_0 = \\mathbf{v}_0 = [0, 7.8 \\times 10^3, 0]^T \\, \\text{m/s}\\) . Velocity derivative: \\(\\dot{\\mathbf{v}}_0 = -\\frac{\\mu}{r_0^3} \\mathbf{r}_0\\) , where \\(r_0 = 6,571 \\times 10^3 \\, \\text{m}\\) , so: \\[ r_0^3 = (6.571 \\times 10^6)^3 \\approx 2.835 \\times 10^{20} \\, \\text{m}^3, \\] \\[ \\frac{\\mu}{r_0^3} = \\frac{3.986 \\times 10^{14}}{2.835 \\times 10^{20}} \\approx 1.406 \\times 10^{-6} \\, \\text{s}^{-2}, \\] \\[ \\dot{\\mathbf{v}}_0 = -1.406 \\times 10^{-6} \\cdot [6.571 \\times 10^6, 0, 0]^T \\approx [-9.24, 0, 0]^T \\, \\text{m/s}^2. \\] Thus, \\(\\frac{d\\mathbf{y}_0}{dt} = [0, 7.8 \\times 10^3, 0, -9.24, 0, 0]^T\\) . The RK4 method computes increments \\(\\mathbf{k}_1, \\mathbf{k}_2, \\mathbf{k}_3, \\mathbf{k}_4\\) based on this and intermediate states, updating \\(\\mathbf{y}_1 = \\mathbf{y}_0 + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\\) . For brevity, we note that this step yields a new position and velocity at \\(t = 1 \\, \\text{s}\\) , slightly adjusted from \\(\\mathbf{y}_0\\) due to gravitational acceleration.","title":"Numerical Integration Step"},{"location":"1%20Physics/2%20Gravity/Problem_3/#verification","text":"To ensure accuracy, we check the specific angular momentum: \\[ \\mathbf{h}_0 = \\mathbf{r}_0 \\times \\mathbf{v}_0 = \\begin{vmatrix} \\hat{\\mathbf{i}} & \\hat{\\mathbf{j}} & \\hat{\\mathbf{k}} \\\\ 6.571 \\times 10^6 & 0 & 0 \\\\ 0 & 7.8 \\times 10^3 & 0 \\end{vmatrix} = (6.571 \\times 10^6 \\cdot 7.8 \\times 10^3) \\hat{\\mathbf{k}} \\approx 5.125 \\times 10^{10} \\, \\hat{\\mathbf{k}} \\, \\text{m}^2 \\text{s}^{-1}. \\] The magnitude \\(h = 5.125 \\times 10^{10} \\, \\text{m}^2 \\text{s}^{-1}\\) should remain constant, verifiable at subsequent time steps. This confirms the trajectory lies in the \\(xy\\) -plane, consistent with our planar assumption.","title":"Verification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications-and-contextual-analysis-of-payload-trajectories","text":"This section explores practical implications of payload trajectories, including orbital insertion, reentry, and escape scenarios, with applications in satellite deployment, mission planning, and planetary exploration.","title":"Applications and Contextual Analysis of Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-trajectories-and-orbital-insertion","text":"For circular orbits, the required velocity is: \\[ v_c = \\sqrt{\\frac{\\mu}{r}}. \\] For elliptical orbits, the velocity satisfies the vis-viva equation: \\[ v = \\sqrt{\\mu \\left( \\frac{2}{r} - \\frac{1}{a} \\right)}. \\] Precise control of \\(\\mathbf{v}_0\\) ensures the desired orbit, minimizing risks of unintended trajectories.","title":"1. Trajectories and Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-trajectories-and-reentry-processes","text":"Reentry dynamics depend on the entry angle \\(\\gamma\\) and velocity. A steep angle causes high heating, while a shallow angle risks skipping off the atmosphere. Escape or bound trajectories are determined by \\(\\epsilon\\) .","title":"2. Trajectories and Reentry Processes"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-trajectories-and-escape-scenarios","text":"Escape requires achieving escape velocity: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2\\mu}{r_0}}. \\] For \\(v_0 > v_{\\text{esc}}\\) , the trajectory is hyperbolic, with excess speed: \\[ v_\\infty = \\sqrt{v_0^2 - \\frac{2\\mu}{r_0}}. \\] Escape trajectories are crucial for interplanetary missions.","title":"3. Trajectories and Escape Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-real-world-applications-satellite-deployment","text":"Satellite deployment relies on precise trajectory control. For GEO, a transfer orbit requires: \\[ v_0 = \\sqrt{\\mu \\left( \\frac{2}{r_0} - \\frac{1}{a} \\right)}, \\] where \\(a\\) is the semi-major axis of the transfer orbit.","title":"4. Real-World Applications: Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-implications-for-space-mission-planning","text":"Trajectory analysis informs launch windows, fuel budgets, and risk assessments. Orbital elements derived from \\(\\mathbf{r}_0\\) and \\(\\mathbf{v}_0\\) guide mission feasibility and collision avoidance.","title":"5. Implications for Space Mission Planning"},{"location":"1%20Physics/2%20Gravity/Problem_3/#6-planetary-exploration-contexts","text":"Interplanetary missions require hyperbolic escape trajectories. For flybys, periapsis distance and speed are determined by: \\[ r_p = \\frac{h^2}{\\mu (1 + e)}. \\] These principles apply to gravity assists and deep-space missions.","title":"6. Planetary Exploration Contexts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#code-and-plots","text":"","title":"Code and Plots"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-in-a-gravitational-field-with-filled-earth","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) if r < R_Earth: # Prevent orbits from going through Earth return [0, 0, 0, 0] a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) # Filter out points inside the Earth x, y_vals = y[0, :], y[1, :] r = np.sqrt(x**2 + y_vals**2) mask = r >= R_Earth x, y_vals = x[mask], y_vals[mask] return t[mask], np.array([x, y_vals]) # Plotting function def plot_orbits(trajectories, earth_radius=R_Earth): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), earth_radius, color='blue', alpha=0.5, label=\"Earth\") ax.add_artist(circle) # Plot trajectories colors = ['red', 'green', 'orange', 'purple', 'cyan', 'magenta'] for i, traj in enumerate(trajectories): if traj[1] is not None: x, y = traj[1][0, :], traj[1][1, :] ax.plot(x, y, label=f\"Trajectory {i+1}\", color=colors[i]) # Add labels and legend ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.legend() ax.grid(True) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.show() # Define initial conditions for multiple trajectories trajectories = [] # Circular orbit y0_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6))] trajectories.append(simulate_orbit(y0_circular, [0, 10000], 1)) # Elliptical orbit (slightly perturbed from circular) y0_elliptical = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.95] trajectories.append(simulate_orbit(y0_elliptical, [0, 10000], 1)) # Reentry trajectory (low velocity) y0_reentry = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.5] trajectories.append(simulate_orbit(y0_reentry, [0, 10000], 1)) # Escape trajectory (high velocity) - Limit the time span y0_escape = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.5] trajectories.append(simulate_orbit(y0_escape, [0, 5000], 1)) # Shorter time span # Partial orbit (70% completion before falling back) y0_partial = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 0.8] trajectories.append(simulate_orbit(y0_partial, [0, 10000], 1)) # New trajectory: slightly faster than circular orbit y0_faster_circular = [R_Earth + 1e6, 0, 0, np.sqrt(G * M_Earth / (R_Earth + 1e6)) * 1.1] trajectories.append(simulate_orbit(y0_faster_circular, [0, 10000], 1)) # Plot all trajectories plot_orbits(trajectories)","title":"Trajectories in a Gravitational Field with Filled Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-in-a-gravitational-field-with-filled-earth_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) if r < R_Earth: # Prevent orbits from going through Earth return [0, 0, 0, 0] a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) # Filter out points inside the Earth x, y_vals = y[0, :], y[1, :] r = np.sqrt(x**2 + y_vals**2) mask = r >= R_Earth x, y_vals = x[mask], y_vals[mask] return t[mask], np.array([x, y_vals]) # Function to plot multiple trajectories def plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000): fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.5, label=\"Earth\") ax.add_artist(circle) colors = plt.cm.viridis(np.linspace(0, 1, len(initial_conditions_list))) for i, (x0, y0, vx0, vy0) in enumerate(initial_conditions_list): y0_initial = [x0, y0, vx0, vy0] t, y = simulate_orbit(y0_initial, [0, t_max], t_max / num_points) x, y_vals = y[0, :], y[1, :] ax.plot(x, y_vals, label=f\"Trajectory {i+1}\", color=colors[i]) # Add labels and legend ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.legend() ax.grid(True) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.show() # Define initial conditions initial_conditions_list = [ (R_Earth + 1e6, 0, 0, 9000), (R_Earth + 1e6, 0, 0, 9100), (R_Earth + 1e6, 0, 0, 9200), (R_Earth + 1e6, 0, 0, 9300), (R_Earth + 1e6, 0, 0, 9400), (R_Earth + 1e6, 0, 0, 9500), (R_Earth + 1e6, 0, 0, 9600), (R_Earth + 1e6, 0, 0, 9700), (R_Earth + 1e6, 0, 0, 9800), (R_Earth + 1e6, 0, 0, 9900), (R_Earth + 1e6, 0, 0, 10000), ] # Call the function plot_trajectories(initial_conditions_list, t_max=100000, num_points=20000)","title":"Trajectories in a Gravitational Field with Filled Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-in-a-gravitational-field-with-filled-earth_2","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_Earth = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Earth's gravitational potential function def acceleration(t, y): x, y, vx, vy = y r = np.sqrt(x**2 + y**2) a_x = -G * M_Earth * x / r**3 a_y = -G * M_Earth * y / r**3 return [vx, vy, a_x, a_y] # Solve the equations of motion using solve_ivp def simulate_orbit(y0, t_span, dt): sol = solve_ivp(acceleration, t_span, y0, dense_output=True, rtol=1e-9, atol=1e-12) t = np.arange(t_span[0], t_span[1], dt) y = sol.sol(t) return t, y # Function to plot multiple trajectories def plot_trajectories(initial_conditions_list, t_max=50000, num_points=100): # Reduced t_max and increased num_points fig, ax = plt.subplots(figsize=(8, 8)) ax.set_aspect('equal') # Draw Earth circle = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.5, label=\"Earth\") ax.add_artist(circle) colors = plt.cm.viridis(np.linspace(0, 1, len(initial_conditions_list))) for i, (x0, y0, vx0, vy0) in enumerate(initial_conditions_list): y0_initial = [x0, y0, vx0, vy0] t, y = simulate_orbit(y0_initial, [0, t_max], t_max / num_points) x, y_vals = y[0, :], y[1, :] ax.plot(x, y_vals, label=f\"Trajectory {i+1}\", color=colors[i]) # Add labels and legend ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.legend() ax.grid(True) plt.title(\"Trajectories in a Gravitational Field with Filled Earth\") plt.show() # Define initial conditions initial_conditions_list = [ (R_Earth + 1e6, 0, 0, 11000), # Starting velocity of 11000 m/s (R_Earth + 1e6, 0, 0, 11500), # Slightly higher velocity (R_Earth + 1e6, 0, 0, 12000), (R_Earth + 1e6, 0, 0, 12500), (R_Earth + 1e6, 0, 0, 13000), (R_Earth + 1e6, 0, 0, 13500), ] # Call the function plot_trajectories(initial_conditions_list, t_max=50000, num_points=100)","title":"Trajectories in a Gravitational Field with Filled Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Problem Setup Selection of Regular Polygon To study interference patterns on the water surface, we begin by selecting a regular polygon. A regular polygon has sides of equal length and angles of equal measure. Examples include: Equilateral triangle Square Regular pentagon The point wave sources will be placed at the vertices of the chosen polygon, ensuring a symmetric spatial configuration. Determination of Vertex Coordinates Assume the center of the polygon is placed at the origin of the coordinate system \\((0,0)\\) . The vertices of a regular \\(n\\) -sided polygon can be calculated using: \\[ (x_i, y_i) = (R \\cos{\\theta_i}, R \\sin{\\theta_i}) \\] where: \\(R\\) is the radius of the circumscribed circle (distance from center to any vertex), \\(\\theta_i = \\theta_0 + \\frac{2\\pi i}{n}\\) is the angular position of vertex \\(i\\) , \\(\\theta_0\\) is an optional initial rotation angle, \\(i \\in \\{0, 1, \\dots, n-1\\}\\) . For simplicity, we often set \\(\\theta_0 = 0\\) so that the first vertex lies on the positive \\(x\\) -axis. Thus, the full set of vertices is given by: \\[ \\{(x_i, y_i)\\ |\\ i = 0, 1, \\dots, n-1\\} \\] Definition of Wave Parameters Each point source emits a circular wave characterized by several key physical parameters: Amplitude : \\(A\\) , the maximum displacement of the water surface. Wavelength : \\(\\lambda\\) , the distance between consecutive wave crests. Frequency : \\(f\\) , the number of oscillations per second (measured in Hz). Wave Number : \\(k\\) , defined as: \\[ k = \\frac{2\\pi}{\\lambda} \\] Angular Frequency : \\(\\omega\\) , defined as: \\[ \\omega = 2\\pi f \\] Initial Phase : \\(\\phi\\) , the phase offset at time \\(t=0\\) and distance \\(r=0\\) . The displacement \\(\\zeta\\) of the water surface from a single source at a given point \\((x,y)\\) and time \\(t\\) is described by the function: \\[ \\zeta(x, y, t) = A \\cos\\left(kr - \\omega t + \\phi\\right) \\] where \\(r\\) is the distance between the source and the point \\((x,y)\\) , given by: \\[ r = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] with \\((x_i, y_i)\\) being the coordinates of the source. Assumptions All sources emit coherent waves, maintaining a constant phase relationship. All sources have identical amplitude, wavelength, frequency, and initial phase, unless otherwise specified. Mathematical Formulation Wave Equation for a Single Source The wave generated by a single point source located at position \\((x_0, y_0)\\) is described by the displacement function: \\[ \\eta(x, y, t) = A \\cos\\left(k r - \\omega t + \\phi\\right) \\] where: \\(\\eta(x, y, t)\\) is the vertical displacement of the water surface at position \\((x,y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k\\) is the wave number \\((k = \\frac{2\\pi}{\\lambda})\\) , \\(r\\) is the distance from the source to the point \\((x,y)\\) , \\(\\omega\\) is the angular frequency \\((\\omega = 2\\pi f)\\) , \\(\\phi\\) is the initial phase of the wave. The distance \\(r\\) between the source and the point of observation is given by: \\[ r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\] Wave Equations for Multiple Sources For \\(n\\) wave sources located at the vertices \\((x_i, y_i)\\) of the chosen regular polygon \\((i = 0, 1, \\dots, n-1)\\) , the displacement contributed by the \\(i\\) -th source is: \\[ \\eta_i(x, y, t) = A \\cos\\left(k r_i - \\omega t + \\phi\\right) \\] where: \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] Each source emits a wave with identical parameters \\((A, k, \\omega, \\phi)\\) but centered at its specific vertex. Superposition Principle According to the superposition principle, the total displacement \\(\\eta_{\\text{total}}(x, y, t)\\) on the water surface is the sum of the displacements due to all individual sources: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{n-1} \\eta_i(x, y, t) \\] Explicitly, this can be written as: \\[ \\eta_{\\text{total}}(x, y, t) = A \\sum_{i=0}^{n-1} \\cos\\left(k \\sqrt{(x - x_i)^2 + (y - y_i)^2} - \\omega t + \\phi\\right) \\] This resulting function \\(\\eta_{\\text{total}}(x, y, t)\\) describes the interference pattern generated by the multiple coherent sources positioned at the vertices of the regular polygon. Analysis of Interference Behavior of the Total Displacement The total displacement \\(\\eta_{\\text{total}}(x, y, t)\\) , resulting from the superposition of waves emitted by all sources, is a function of both spatial coordinates \\((x, y)\\) and time \\(t\\) . It captures the dynamic interference effects across the water surface. At any fixed moment in time, \\(\\eta_{\\text{total}}(x, y, t)\\) provides a snapshot of the interference pattern, characterized by spatial variations in amplitude due to the constructive and destructive interactions of individual wave contributions. Formally: \\[ \\eta_{\\text{total}}(x, y, t) = A \\sum_{i=0}^{n-1} \\cos\\left(k \\sqrt{(x - x_i)^2 + (y - y_i)^2} - \\omega t + \\phi\\right) \\] Constructive and Destructive Interference Interference phenomena arise from the phase relationships between the individual wave contributions at each point: Constructive Interference : Occurs when the phase difference between waves leads to reinforcement, resulting in a local maximum in displacement amplitude. Mathematically, constructive interference at a point \\((x, y)\\) occurs when the phases satisfy: \\[ k(r_i - r_j) = 2m\\pi \\] for integers \\(m\\) , and for all pairs of sources \\(i\\) , \\(j\\) . Destructive Interference : Occurs when the phase difference between waves leads to cancellation, resulting in a local minimum or null in displacement amplitude. Destructive interference occurs when: \\[ k(r_i - r_j) = (2m + 1)\\pi \\] for integers \\(m\\) . Thus, the local interference condition depends on the relative path differences \\(r_i - r_j\\) between sources. Influence of Polygon Geometry The geometry of the chosen regular polygon \u2014 specifically, the number of sides \\(n\\) and the spacing between vertices \u2014 significantly affects the resulting interference pattern: Number of Sides ( \\(n\\) ) : Increasing \\(n\\) increases the number of wave sources, leading to more complex interference structures. For larger \\(n\\) , the system approaches circular symmetry. Vertex Spacing : The distance between adjacent vertices affects the spatial frequency of interference fringes. Closer vertices result in broader fringes; more widely spaced vertices yield finer, more intricate patterns. Symmetry : Due to the regularity of the polygon, the interference pattern inherits a high degree of symmetry. For example: An equilateral triangle results in a threefold rotational symmetry in the interference pattern. A square leads to fourfold symmetry, with prominent constructive regions aligned along the diagonals. A pentagon results in fivefold symmetry, creating more complex but still ordered patterns. Understanding how these geometric factors influence \\(\\eta_{\\text{total}}(x, y, t)\\) is crucial for predicting and interpreting the observed interference structures. Code and Plots One source import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Position of the single source (center of the grid) source_x, source_y = 0.0, 0.0 # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Animation function def update(frame): t = frame / 10.0 # Time step Z = single_wave_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Wave Propagation from a Single Source\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = single_wave_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('single_drop_animation.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('single_drop_animation.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml()) Two sources import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the two sources source_x1, source_y1 = -3.0, 0.0 # First source source_x2, source_y2 = 3.0, 0.0 # Second source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to both sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Total displacement (superposition) return h1 + h2 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Two Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('two_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('two_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml()) Three sources import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the three sources (arranged in an equilateral triangle) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(2 * np.pi / 3), radius * np.sin(2 * np.pi / 3) # Second source source_x3, source_y3 = radius * np.cos(4 * np.pi / 3), radius * np.sin(4 * np.pi / 3) # Third source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all three sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Total displacement (superposition) return h1 + h2 + h3 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Three Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('three_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('three_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml()) Four sources import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the four sources (arranged in a square) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(np.pi / 2), radius * np.sin(np.pi / 2) # Second source source_x3, source_y3 = radius * np.cos(np.pi), radius * np.sin(np.pi) # Third source source_x4, source_y4 = radius * np.cos(3 * np.pi / 2), radius * np.sin(3 * np.pi / 2) # Fourth source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all four sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Displacement from the fourth source h4 = single_wave_displacement(X, Y, source_x4, source_y4, t) # Total displacement (superposition) return h1 + h2 + h3 + h4 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Four Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('four_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('four_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml()) Five sources import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the five sources (arranged in a regular pentagon) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(2 * np.pi / 5), radius * np.sin(2 * np.pi / 5) # Second source source_x3, source_y3 = radius * np.cos(4 * np.pi / 5), radius * np.sin(4 * np.pi / 5) # Third source source_x4, source_y4 = radius * np.cos(6 * np.pi / 5), radius * np.sin(6 * np.pi / 5) # Fourth source source_x5, source_y5 = radius * np.cos(8 * np.pi / 5), radius * np.sin(8 * np.pi / 5) # Fifth source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all five sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Displacement from the fourth source h4 = single_wave_displacement(X, Y, source_x4, source_y4, t) # Displacement from the fifth source h5 = single_wave_displacement(X, Y, source_x5, source_y5, t) # Total displacement (superposition) return h1 + h2 + h3 + h4 + h5 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Five Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('five_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('five_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml()) Thirty sources import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the four sources (arranged in a square) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(np.pi / 2), radius * np.sin(np.pi / 2) # Second source source_x3, source_y3 = radius * np.cos(np.pi), radius * np.sin(np.pi) # Third source source_x4, source_y4 = radius * np.cos(3 * np.pi / 2), radius * np.sin(3 * np.pi / 2) # Fourth source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all four sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Displacement from the fourth source h4 = single_wave_displacement(X, Y, source_x4, source_y4, t) # Total displacement (superposition) return h1 + h2 + h3 + h4 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Four Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('four_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('four_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml()) Colab Colab","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-setup","text":"","title":"Problem Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#selection-of-regular-polygon","text":"To study interference patterns on the water surface, we begin by selecting a regular polygon. A regular polygon has sides of equal length and angles of equal measure. Examples include: Equilateral triangle Square Regular pentagon The point wave sources will be placed at the vertices of the chosen polygon, ensuring a symmetric spatial configuration.","title":"Selection of Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#determination-of-vertex-coordinates","text":"Assume the center of the polygon is placed at the origin of the coordinate system \\((0,0)\\) . The vertices of a regular \\(n\\) -sided polygon can be calculated using: \\[ (x_i, y_i) = (R \\cos{\\theta_i}, R \\sin{\\theta_i}) \\] where: \\(R\\) is the radius of the circumscribed circle (distance from center to any vertex), \\(\\theta_i = \\theta_0 + \\frac{2\\pi i}{n}\\) is the angular position of vertex \\(i\\) , \\(\\theta_0\\) is an optional initial rotation angle, \\(i \\in \\{0, 1, \\dots, n-1\\}\\) . For simplicity, we often set \\(\\theta_0 = 0\\) so that the first vertex lies on the positive \\(x\\) -axis. Thus, the full set of vertices is given by: \\[ \\{(x_i, y_i)\\ |\\ i = 0, 1, \\dots, n-1\\} \\]","title":"Determination of Vertex Coordinates"},{"location":"1%20Physics/3%20Waves/Problem_1/#definition-of-wave-parameters","text":"Each point source emits a circular wave characterized by several key physical parameters: Amplitude : \\(A\\) , the maximum displacement of the water surface. Wavelength : \\(\\lambda\\) , the distance between consecutive wave crests. Frequency : \\(f\\) , the number of oscillations per second (measured in Hz). Wave Number : \\(k\\) , defined as: \\[ k = \\frac{2\\pi}{\\lambda} \\] Angular Frequency : \\(\\omega\\) , defined as: \\[ \\omega = 2\\pi f \\] Initial Phase : \\(\\phi\\) , the phase offset at time \\(t=0\\) and distance \\(r=0\\) . The displacement \\(\\zeta\\) of the water surface from a single source at a given point \\((x,y)\\) and time \\(t\\) is described by the function: \\[ \\zeta(x, y, t) = A \\cos\\left(kr - \\omega t + \\phi\\right) \\] where \\(r\\) is the distance between the source and the point \\((x,y)\\) , given by: \\[ r = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] with \\((x_i, y_i)\\) being the coordinates of the source.","title":"Definition of Wave Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#assumptions","text":"All sources emit coherent waves, maintaining a constant phase relationship. All sources have identical amplitude, wavelength, frequency, and initial phase, unless otherwise specified.","title":"Assumptions"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-formulation","text":"","title":"Mathematical Formulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation-for-a-single-source","text":"The wave generated by a single point source located at position \\((x_0, y_0)\\) is described by the displacement function: \\[ \\eta(x, y, t) = A \\cos\\left(k r - \\omega t + \\phi\\right) \\] where: \\(\\eta(x, y, t)\\) is the vertical displacement of the water surface at position \\((x,y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k\\) is the wave number \\((k = \\frac{2\\pi}{\\lambda})\\) , \\(r\\) is the distance from the source to the point \\((x,y)\\) , \\(\\omega\\) is the angular frequency \\((\\omega = 2\\pi f)\\) , \\(\\phi\\) is the initial phase of the wave. The distance \\(r\\) between the source and the point of observation is given by: \\[ r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\]","title":"Wave Equation for a Single Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equations-for-multiple-sources","text":"For \\(n\\) wave sources located at the vertices \\((x_i, y_i)\\) of the chosen regular polygon \\((i = 0, 1, \\dots, n-1)\\) , the displacement contributed by the \\(i\\) -th source is: \\[ \\eta_i(x, y, t) = A \\cos\\left(k r_i - \\omega t + \\phi\\right) \\] where: \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] Each source emits a wave with identical parameters \\((A, k, \\omega, \\phi)\\) but centered at its specific vertex.","title":"Wave Equations for Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"According to the superposition principle, the total displacement \\(\\eta_{\\text{total}}(x, y, t)\\) on the water surface is the sum of the displacements due to all individual sources: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=0}^{n-1} \\eta_i(x, y, t) \\] Explicitly, this can be written as: \\[ \\eta_{\\text{total}}(x, y, t) = A \\sum_{i=0}^{n-1} \\cos\\left(k \\sqrt{(x - x_i)^2 + (y - y_i)^2} - \\omega t + \\phi\\right) \\] This resulting function \\(\\eta_{\\text{total}}(x, y, t)\\) describes the interference pattern generated by the multiple coherent sources positioned at the vertices of the regular polygon.","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis-of-interference","text":"","title":"Analysis of Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#behavior-of-the-total-displacement","text":"The total displacement \\(\\eta_{\\text{total}}(x, y, t)\\) , resulting from the superposition of waves emitted by all sources, is a function of both spatial coordinates \\((x, y)\\) and time \\(t\\) . It captures the dynamic interference effects across the water surface. At any fixed moment in time, \\(\\eta_{\\text{total}}(x, y, t)\\) provides a snapshot of the interference pattern, characterized by spatial variations in amplitude due to the constructive and destructive interactions of individual wave contributions. Formally: \\[ \\eta_{\\text{total}}(x, y, t) = A \\sum_{i=0}^{n-1} \\cos\\left(k \\sqrt{(x - x_i)^2 + (y - y_i)^2} - \\omega t + \\phi\\right) \\]","title":"Behavior of the Total Displacement"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-and-destructive-interference","text":"Interference phenomena arise from the phase relationships between the individual wave contributions at each point: Constructive Interference : Occurs when the phase difference between waves leads to reinforcement, resulting in a local maximum in displacement amplitude. Mathematically, constructive interference at a point \\((x, y)\\) occurs when the phases satisfy: \\[ k(r_i - r_j) = 2m\\pi \\] for integers \\(m\\) , and for all pairs of sources \\(i\\) , \\(j\\) . Destructive Interference : Occurs when the phase difference between waves leads to cancellation, resulting in a local minimum or null in displacement amplitude. Destructive interference occurs when: \\[ k(r_i - r_j) = (2m + 1)\\pi \\] for integers \\(m\\) . Thus, the local interference condition depends on the relative path differences \\(r_i - r_j\\) between sources.","title":"Constructive and Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#influence-of-polygon-geometry","text":"The geometry of the chosen regular polygon \u2014 specifically, the number of sides \\(n\\) and the spacing between vertices \u2014 significantly affects the resulting interference pattern: Number of Sides ( \\(n\\) ) : Increasing \\(n\\) increases the number of wave sources, leading to more complex interference structures. For larger \\(n\\) , the system approaches circular symmetry. Vertex Spacing : The distance between adjacent vertices affects the spatial frequency of interference fringes. Closer vertices result in broader fringes; more widely spaced vertices yield finer, more intricate patterns. Symmetry : Due to the regularity of the polygon, the interference pattern inherits a high degree of symmetry. For example: An equilateral triangle results in a threefold rotational symmetry in the interference pattern. A square leads to fourfold symmetry, with prominent constructive regions aligned along the diagonals. A pentagon results in fivefold symmetry, creating more complex but still ordered patterns. Understanding how these geometric factors influence \\(\\eta_{\\text{total}}(x, y, t)\\) is crucial for predicting and interpreting the observed interference structures.","title":"Influence of Polygon Geometry"},{"location":"1%20Physics/3%20Waves/Problem_1/#code-and-plots","text":"","title":"Code and Plots"},{"location":"1%20Physics/3%20Waves/Problem_1/#one-source","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Position of the single source (center of the grid) source_x, source_y = 0.0, 0.0 # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Animation function def update(frame): t = frame / 10.0 # Time step Z = single_wave_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Wave Propagation from a Single Source\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = single_wave_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('single_drop_animation.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('single_drop_animation.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml())","title":"One source"},{"location":"1%20Physics/3%20Waves/Problem_1/#two-sources","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the two sources source_x1, source_y1 = -3.0, 0.0 # First source source_x2, source_y2 = 3.0, 0.0 # Second source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to both sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Total displacement (superposition) return h1 + h2 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Two Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('two_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('two_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml())","title":"Two sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#three-sources","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the three sources (arranged in an equilateral triangle) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(2 * np.pi / 3), radius * np.sin(2 * np.pi / 3) # Second source source_x3, source_y3 = radius * np.cos(4 * np.pi / 3), radius * np.sin(4 * np.pi / 3) # Third source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all three sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Total displacement (superposition) return h1 + h2 + h3 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Three Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('three_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('three_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml())","title":"Three sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#four-sources","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the four sources (arranged in a square) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(np.pi / 2), radius * np.sin(np.pi / 2) # Second source source_x3, source_y3 = radius * np.cos(np.pi), radius * np.sin(np.pi) # Third source source_x4, source_y4 = radius * np.cos(3 * np.pi / 2), radius * np.sin(3 * np.pi / 2) # Fourth source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all four sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Displacement from the fourth source h4 = single_wave_displacement(X, Y, source_x4, source_y4, t) # Total displacement (superposition) return h1 + h2 + h3 + h4 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Four Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('four_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('four_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml())","title":"Four sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#five-sources","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the five sources (arranged in a regular pentagon) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(2 * np.pi / 5), radius * np.sin(2 * np.pi / 5) # Second source source_x3, source_y3 = radius * np.cos(4 * np.pi / 5), radius * np.sin(4 * np.pi / 5) # Third source source_x4, source_y4 = radius * np.cos(6 * np.pi / 5), radius * np.sin(6 * np.pi / 5) # Fourth source source_x5, source_y5 = radius * np.cos(8 * np.pi / 5), radius * np.sin(8 * np.pi / 5) # Fifth source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all five sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Displacement from the fourth source h4 = single_wave_displacement(X, Y, source_x4, source_y4, t) # Displacement from the fifth source h5 = single_wave_displacement(X, Y, source_x5, source_y5, t) # Total displacement (superposition) return h1 + h2 + h3 + h4 + h5 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Five Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('five_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('five_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml())","title":"Five sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#thirty-sources","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from google.colab import files # For downloading the file # Parameters amplitude = 1.0 # Amplitude of the waves wavelength = 1.0 # Wavelength of the waves frequency = 1.0 # Frequency of the waves k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi * frequency # Angular frequency initial_phase = 0.0 # Initial phase # Grid for the water surface (reduced resolution to avoid large file size) x = np.linspace(-10, 10, 300) # Reduced from 500 to 300 y = np.linspace(-10, 10, 300) X, Y = np.meshgrid(x, y) # Positions of the four sources (arranged in a square) radius = 5.0 # Distance of sources from the center source_x1, source_y1 = radius * np.cos(0), radius * np.sin(0) # First source source_x2, source_y2 = radius * np.cos(np.pi / 2), radius * np.sin(np.pi / 2) # Second source source_x3, source_y3 = radius * np.cos(np.pi), radius * np.sin(np.pi) # Third source source_x4, source_y4 = radius * np.cos(3 * np.pi / 2), radius * np.sin(3 * np.pi / 2) # Fourth source # Function to calculate the displacement of a single wave source def single_wave_displacement(X, Y, source_x, source_y, t): r = np.sqrt((X - source_x)**2 + (Y - source_y)**2) # Distance from source return amplitude * np.cos(k * r - omega * t + initial_phase) # Function to calculate the total displacement due to all four sources def total_displacement(X, Y, t): # Displacement from the first source h1 = single_wave_displacement(X, Y, source_x1, source_y1, t) # Displacement from the second source h2 = single_wave_displacement(X, Y, source_x2, source_y2, t) # Displacement from the third source h3 = single_wave_displacement(X, Y, source_x3, source_y3, t) # Displacement from the fourth source h4 = single_wave_displacement(X, Y, source_x4, source_y4, t) # Total displacement (superposition) return h1 + h2 + h3 + h4 # Animation function def update(frame): t = frame / 10.0 # Time step Z = total_displacement(X, Y, t) im.set_array(Z) return [im] # Create the figure and axis fig, ax = plt.subplots(figsize=(8, 8)) ax.set_title(\"Interference Patterns from Four Sources\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # Initial plot Z = total_displacement(X, Y, 0.0) im = ax.imshow(Z, extent=[x.min(), x.max(), y.min(), y.max()], origin='lower', cmap='coolwarm') cbar = fig.colorbar(im, ax=ax) cbar.set_label(\"Displacement\") # Animation ani = FuncAnimation(fig, update, frames=range(0, 100), interval=50, blit=True) # Save the animation as a GIF ani.save('four_source_interference.gif', writer=PillowWriter(fps=10)) # Automatically download the GIF files.download('four_source_interference.gif') # Display the animation in Colab from IPython.display import HTML HTML(ani.to_jshtml())","title":"Thirty sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Applications of the Lorentz Force 1. Exploration of Applications The Lorentz force , given by $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}), $$ describes the total force on a charged particle of charge \\(q\\) , moving with velocity \\(\\vec{v}\\) in the presence of electric \\(\\vec{E}\\) and magnetic \\(\\vec{B}\\) fields. Particle Accelerators In linear accelerators (linacs) and cyclotrons , electric fields are used to accelerate particles, while magnetic fields control their trajectories. For particles moving perpendicular to a uniform magnetic field: $$ F = qvB \\Rightarrow \\frac{mv^2}{r} = qvB \\Rightarrow r = \\frac{mv}{qB} $$ Radius of curvature \\(r\\) increases with velocity \\(v\\) , thus magnetic fields provide velocity-dependent steering . Mass Spectrometers Mass spectrometry relies on separating ions by their mass-to-charge ratio \\(\\frac{m}{q}\\) using the Lorentz force. Charged ions entering a region with \\(\\vec{E} = 0\\) and uniform \\(\\vec{B}\\) field perpendicular to velocity: $$ r = \\frac{mv}{qB} $$ With kinetic energy imparted by a known potential \\(V\\) : $$ \\frac{1}{2}mv^2 = qV \\Rightarrow v = \\sqrt{\\frac{2qV}{m}} \\Rightarrow r = \\frac{\\sqrt{2mV}}{qB} $$ Measured radius \\(r\\) allows determination of \\(m/q\\) : $$ \\frac{m}{q} = \\frac{r^2 B^2}{2V} $$ Plasma Confinement In tokamaks and stellarators , magnetic fields are crucial for confining high-energy plasma. In the absence of electric field, charged particles exhibit helical motion around magnetic field lines: $$ \\text{Gyrofrequency: } \\omega_c = \\frac{qB}{m}, \\quad \\text{Larmor radius: } r_L = \\frac{mv_\\perp}{qB} $$ The Lorentz force prevents charged particles from escaping perpendicularly, while toroidal magnetic fields maintain containment. E\u00d7B drift occurs when both \\(\\vec{E}\\) and \\(\\vec{B}\\) are present: $$ \\vec{v}_{E \\times B} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ This drift is independent of charge and mass . Magnetic mirrors exploit varying \\(B\\) field strengths: $$ \\mu = \\frac{mv_\\perp^2}{2B} = \\text{constant} \\Rightarrow \\text{confinement via reflection at high } B $$ Role of Fields in Charged Particle Motion Electric fields do work on particles: $$ \\vec{F}_E = q\\vec{E}, \\quad W = qEd $$ Magnetic fields alter direction, not speed: $$ \\vec{F}_B = q\\vec{v} \\times \\vec{B}, \\quad \\vec{v} \\cdot \\vec{F}_B = 0 $$ Combined fields produce complex motion: Spiral/helical paths Cyclotron resonance when \\(\\omega = \\omega_c\\) Cross-field drifts critical in fusion and space physics 2. Parameter Exploration Analyzing the effects of varying physical parameters in the Lorentz force $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ provides insights into charged particle dynamics under controlled experimental or simulated conditions. Electric and Magnetic Field Strengths \\((\\vec{E}, \\vec{B})\\) Electric Field \\(\\vec{E}\\) : Alters particle kinetic energy directly: $$ \\vec{F}_E = q\\vec{E}, \\quad a = \\frac{q\\vec{E}}{m}, \\quad \\Delta v = \\frac{q\\vec{E}}{m} \\Delta t $$ Linear acceleration for uniform \\(\\vec{E}\\) Direction depends on the sign of \\(q\\) Magnetic Field \\(\\vec{B}\\) : Influences trajectory curvature , not speed: $$ \\vec{F} B = q\\vec{v} \\times \\vec{B}, \\quad r = \\frac{mv \\perp}{qB}, \\quad \\omega_c = \\frac{qB}{m} $$ Stronger \\(B\\) \\(\\Rightarrow\\) tighter curvature Direction follows right-hand rule (positive \\(q\\) ) Initial Particle Velocity \\(\\vec{v}\\) Magnitude of \\(\\vec{v}\\) affects both electric and magnetic interactions: $$ |\\vec{F}_B| = qvB \\sin\\theta $$ \\(\\theta = 90^\\circ\\) maximizes magnetic force For \\(\\vec{v} \\parallel \\vec{B}\\) , no magnetic deflection occurs Particle speed \\(v\\) determines: Radius of curvature \\(r\\) Helical pitch in combined \\(\\vec{E}\\) and \\(\\vec{B}\\) fields Energy gained via \\(\\vec{E}\\) : \\(K = \\frac{1}{2}mv^2\\) Particle Charge and Mass \\((q, m)\\) Charge \\(q\\) : Sign affects force direction: \\(\\vec{F} \\propto q\\) Magnitude scales force linearly: $$ \\vec{F} \\propto q, \\quad r \\propto \\frac{1}{q} $$ Mass \\(m\\) : Influences inertia, acceleration response: $$ a = \\frac{F}{m}, \\quad r \\propto m, \\quad \\omega_c \\propto \\frac{1}{m} $$ Trajectory Response to Parameter Changes Case Studies: Increase \\(E\\) : \u2192 Faster acceleration along field lines, linear velocity growth. Increase \\(B\\) : \u2192 Decreased gyro-radius \\(r\\) , increased cyclotron frequency \\(\\omega_c\\) . Increase \\(v_\\perp\\) : \u2192 Larger \\(r\\) , wider spiral. Switch sign of \\(q\\) : \u2192 Force vector reverses; trajectory curves in opposite direction. Increase \\(m\\) : \u2192 Slower acceleration, wider spiral path due to increased inertia. Tracking Motion Use numerical methods (e.g., Runge-Kutta) to integrate: $$ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ and $$ \\frac{d\\vec{r}}{dt} = \\vec{v} $$ Trajectory sensitivity analysis is vital in: - Plasma control - Ion-beam focusing - Spacecraft propulsion simulations Code and Plots Website with simulation Simulation Uniform Magnetic Field Only (Helical Motion) # Case (a): Uniform Magnetic Field Only (Helical Motion) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Lorentz force def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) # Euler method def simulate_particle(q, m, E, B, v0, r0, dt, steps): v = np.array(v0, dtype=float) r = np.array(r0, dtype=float) positions = [r.copy()] for _ in range(steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) # 3D plot def plot_3d(positions, title='3D Trajectory'): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(title) plt.show() # Parameters q = 1.0 m = 1.0 B = np.array([0, 0, 1]) E = np.array([0, 0, 0]) v0 = [1, 0, 1] r0 = [0, 0, 0] dt = 0.01 steps = 1000 # Run simulation positions = simulate_particle(q, m, E, B, v0, r0, dt, steps) plot_3d(positions, title='Uniform Magnetic Field (Helical Motion)') Aligned Electric and Magnetic Fields # Case (b): Aligned Electric and Magnetic Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) def simulate_particle(q, m, E, B, v0, r0, dt, steps): v = np.array(v0, dtype=float) r = np.array(r0, dtype=float) positions = [r.copy()] for _ in range(steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) def plot_3d(positions, title='3D Trajectory'): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(title) plt.show() q = 1.0 m = 1.0 B = np.array([0, 0, 1]) E = np.array([0, 0, 1]) v0 = [1, 0, 0] r0 = [0, 0, 0] dt = 0.01 steps = 1000 positions = simulate_particle(q, m, E, B, v0, r0, dt, steps) plot_3d(positions, title='Aligned Electric and Magnetic Fields') Crossed Electric and Magnetic Fields (E \u00d7 B Drift) # Case (c): Crossed Electric and Magnetic Fields (E \u00d7 B Drift) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) def simulate_particle(q, m, E, B, v0, r0, dt, steps): v = np.array(v0, dtype=float) r = np.array(r0, dtype=float) positions = [r.copy()] for _ in range(steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) def plot_3d(positions, title='3D Trajectory'): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(title) plt.show() q = 1.0 m = 1.0 B = np.array([0, 0, 1]) E = np.array([1, 0, 0]) v0 = [0, 0, 0] r0 = [0, 0, 0] dt = 0.01 steps = 1000 positions = simulate_particle(q, m, E, B, v0, r0, dt, steps) plot_3d(positions, title='Crossed Electric and Magnetic Fields (E \u00d7 B Drift)') Colab Colab","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force , given by $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}), $$ describes the total force on a charged particle of charge \\(q\\) , moving with velocity \\(\\vec{v}\\) in the presence of electric \\(\\vec{E}\\) and magnetic \\(\\vec{B}\\) fields.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","text":"In linear accelerators (linacs) and cyclotrons , electric fields are used to accelerate particles, while magnetic fields control their trajectories. For particles moving perpendicular to a uniform magnetic field: $$ F = qvB \\Rightarrow \\frac{mv^2}{r} = qvB \\Rightarrow r = \\frac{mv}{qB} $$ Radius of curvature \\(r\\) increases with velocity \\(v\\) , thus magnetic fields provide velocity-dependent steering .","title":"Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mass-spectrometers","text":"Mass spectrometry relies on separating ions by their mass-to-charge ratio \\(\\frac{m}{q}\\) using the Lorentz force. Charged ions entering a region with \\(\\vec{E} = 0\\) and uniform \\(\\vec{B}\\) field perpendicular to velocity: $$ r = \\frac{mv}{qB} $$ With kinetic energy imparted by a known potential \\(V\\) : $$ \\frac{1}{2}mv^2 = qV \\Rightarrow v = \\sqrt{\\frac{2qV}{m}} \\Rightarrow r = \\frac{\\sqrt{2mV}}{qB} $$ Measured radius \\(r\\) allows determination of \\(m/q\\) : $$ \\frac{m}{q} = \\frac{r^2 B^2}{2V} $$","title":"Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement","text":"In tokamaks and stellarators , magnetic fields are crucial for confining high-energy plasma. In the absence of electric field, charged particles exhibit helical motion around magnetic field lines: $$ \\text{Gyrofrequency: } \\omega_c = \\frac{qB}{m}, \\quad \\text{Larmor radius: } r_L = \\frac{mv_\\perp}{qB} $$ The Lorentz force prevents charged particles from escaping perpendicularly, while toroidal magnetic fields maintain containment. E\u00d7B drift occurs when both \\(\\vec{E}\\) and \\(\\vec{B}\\) are present: $$ \\vec{v}_{E \\times B} = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ This drift is independent of charge and mass . Magnetic mirrors exploit varying \\(B\\) field strengths: $$ \\mu = \\frac{mv_\\perp^2}{2B} = \\text{constant} \\Rightarrow \\text{confinement via reflection at high } B $$","title":"Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-fields-in-charged-particle-motion","text":"Electric fields do work on particles: $$ \\vec{F}_E = q\\vec{E}, \\quad W = qEd $$ Magnetic fields alter direction, not speed: $$ \\vec{F}_B = q\\vec{v} \\times \\vec{B}, \\quad \\vec{v} \\cdot \\vec{F}_B = 0 $$ Combined fields produce complex motion: Spiral/helical paths Cyclotron resonance when \\(\\omega = \\omega_c\\) Cross-field drifts critical in fusion and space physics","title":"Role of Fields in Charged Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-parameter-exploration","text":"Analyzing the effects of varying physical parameters in the Lorentz force $$ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ provides insights into charged particle dynamics under controlled experimental or simulated conditions.","title":"2. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electric-and-magnetic-field-strengths-vece-vecb","text":"Electric Field \\(\\vec{E}\\) : Alters particle kinetic energy directly: $$ \\vec{F}_E = q\\vec{E}, \\quad a = \\frac{q\\vec{E}}{m}, \\quad \\Delta v = \\frac{q\\vec{E}}{m} \\Delta t $$ Linear acceleration for uniform \\(\\vec{E}\\) Direction depends on the sign of \\(q\\) Magnetic Field \\(\\vec{B}\\) : Influences trajectory curvature , not speed: $$ \\vec{F} B = q\\vec{v} \\times \\vec{B}, \\quad r = \\frac{mv \\perp}{qB}, \\quad \\omega_c = \\frac{qB}{m} $$ Stronger \\(B\\) \\(\\Rightarrow\\) tighter curvature Direction follows right-hand rule (positive \\(q\\) )","title":"Electric and Magnetic Field Strengths \\((\\vec{E}, \\vec{B})\\)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initial-particle-velocity-vecv","text":"Magnitude of \\(\\vec{v}\\) affects both electric and magnetic interactions: $$ |\\vec{F}_B| = qvB \\sin\\theta $$ \\(\\theta = 90^\\circ\\) maximizes magnetic force For \\(\\vec{v} \\parallel \\vec{B}\\) , no magnetic deflection occurs Particle speed \\(v\\) determines: Radius of curvature \\(r\\) Helical pitch in combined \\(\\vec{E}\\) and \\(\\vec{B}\\) fields Energy gained via \\(\\vec{E}\\) : \\(K = \\frac{1}{2}mv^2\\)","title":"Initial Particle Velocity \\(\\vec{v}\\)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-charge-and-mass-q-m","text":"Charge \\(q\\) : Sign affects force direction: \\(\\vec{F} \\propto q\\) Magnitude scales force linearly: $$ \\vec{F} \\propto q, \\quad r \\propto \\frac{1}{q} $$ Mass \\(m\\) : Influences inertia, acceleration response: $$ a = \\frac{F}{m}, \\quad r \\propto m, \\quad \\omega_c \\propto \\frac{1}{m} $$","title":"Particle Charge and Mass \\((q, m)\\)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#trajectory-response-to-parameter-changes","text":"","title":"Trajectory Response to Parameter Changes"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-studies","text":"Increase \\(E\\) : \u2192 Faster acceleration along field lines, linear velocity growth. Increase \\(B\\) : \u2192 Decreased gyro-radius \\(r\\) , increased cyclotron frequency \\(\\omega_c\\) . Increase \\(v_\\perp\\) : \u2192 Larger \\(r\\) , wider spiral. Switch sign of \\(q\\) : \u2192 Force vector reverses; trajectory curves in opposite direction. Increase \\(m\\) : \u2192 Slower acceleration, wider spiral path due to increased inertia.","title":"Case Studies:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#tracking-motion","text":"Use numerical methods (e.g., Runge-Kutta) to integrate: $$ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}) $$ and $$ \\frac{d\\vec{r}}{dt} = \\vec{v} $$ Trajectory sensitivity analysis is vital in: - Plasma control - Ion-beam focusing - Spacecraft propulsion simulations","title":"Tracking Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#code-and-plots","text":"","title":"Code and Plots"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#website-with-simulation","text":"Simulation","title":"Website with simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#uniform-magnetic-field-only-helical-motion","text":"# Case (a): Uniform Magnetic Field Only (Helical Motion) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Lorentz force def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) # Euler method def simulate_particle(q, m, E, B, v0, r0, dt, steps): v = np.array(v0, dtype=float) r = np.array(r0, dtype=float) positions = [r.copy()] for _ in range(steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) # 3D plot def plot_3d(positions, title='3D Trajectory'): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(title) plt.show() # Parameters q = 1.0 m = 1.0 B = np.array([0, 0, 1]) E = np.array([0, 0, 0]) v0 = [1, 0, 1] r0 = [0, 0, 0] dt = 0.01 steps = 1000 # Run simulation positions = simulate_particle(q, m, E, B, v0, r0, dt, steps) plot_3d(positions, title='Uniform Magnetic Field (Helical Motion)')","title":"Uniform Magnetic Field Only (Helical Motion)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#aligned-electric-and-magnetic-fields","text":"# Case (b): Aligned Electric and Magnetic Fields import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) def simulate_particle(q, m, E, B, v0, r0, dt, steps): v = np.array(v0, dtype=float) r = np.array(r0, dtype=float) positions = [r.copy()] for _ in range(steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) def plot_3d(positions, title='3D Trajectory'): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(title) plt.show() q = 1.0 m = 1.0 B = np.array([0, 0, 1]) E = np.array([0, 0, 1]) v0 = [1, 0, 0] r0 = [0, 0, 0] dt = 0.01 steps = 1000 positions = simulate_particle(q, m, E, B, v0, r0, dt, steps) plot_3d(positions, title='Aligned Electric and Magnetic Fields')","title":"Aligned Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#crossed-electric-and-magnetic-fields-e-b-drift","text":"# Case (c): Crossed Electric and Magnetic Fields (E \u00d7 B Drift) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v): return (q / m) * (E + np.cross(v, B)) def simulate_particle(q, m, E, B, v0, r0, dt, steps): v = np.array(v0, dtype=float) r = np.array(r0, dtype=float) positions = [r.copy()] for _ in range(steps): a = lorentz_force(q, m, E, B, v) v += a * dt r += v * dt positions.append(r.copy()) return np.array(positions) def plot_3d(positions, title='3D Trajectory'): fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(title) plt.show() q = 1.0 m = 1.0 B = np.array([0, 0, 1]) E = np.array([1, 0, 0]) v0 = [0, 0, 0] r0 = [0, 0, 0] dt = 0.01 steps = 1000 positions = simulate_particle(q, m, E, B, v0, r0, dt, steps) plot_3d(positions, title='Crossed Electric and Magnetic Fields (E \u00d7 B Drift)')","title":"Crossed Electric and Magnetic Fields (E \u00d7 B Drift)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#colab","text":"Colab","title":"Colab"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 I. Problem Understanding and Modeling 1. Circuit Representation Definition 1.1 (Weighted Undirected Graph). A circuit is modeled by a weighted undirected graph $$ G = (V, E, w), $$ where - \\(V = \\{v_1, v_2, \\dots, v_n\\}\\) is the set of nodes (junctions); - \\(E \\subseteq \\{\\{v_i, v_j\\} : v_i \\neq v_j\\}\\) is the set of edges (resistors); - \\(w: E \\to \\mathbb{R}^+\\) assigns each edge \\(\\{v_i,v_j\\}\\) a resistance \\(r_{ij} = w(\\{v_i,v_j\\})\\) . Adjacency Matrix \\(A\\) . $$ A_{ij} = \\begin{cases} r_{ij}, & {v_i, v_j} \\in E,\\ 0, & \\text{otherwise}, \\end{cases} \\quad A \\in \\mathbb{R}^{n \\times n},\\ A_{ij}=A_{ji},\\ A_{ii}=0. $$ Degree Matrix \\(D\\) and Laplacian \\(L\\) . Let $$ D = \\mathrm{diag}(d_1,\\dots,d_n), \\quad d_i = \\sum_{j=1}^n A_{ij}. $$ Then the graph Laplacian is $$ L = D - A. $$ Connectivity is equivalent to the algebraic connectivity satisfying $$ \\lambda_2(L) > 0. $$ Incidence Matrix \\(B\\) . For \\(m=|E|\\) , define \\(B\\in\\{-1,0,1\\}^{n\\times m}\\) by arbitrarily orienting each edge \\(e_k=\\{v_i,v_j\\}\\) : $$ B_{ik} = \\begin{cases} 1, & \\text{if } e_k \\text{ is oriented } v_i\\to v_j,\\ -1, & \\text{if } e_k \\text{ is oriented } v_j\\to v_i,\\ 0, & \\text{otherwise}. \\end{cases} $$ 2. Input Specification We adopt one of the following formats: Adjacency List. A function \\(L: V \\to 2^{V\\times\\mathbb{R}^+}\\) where $$ L(v_i) = {(v_j, r_{ij}) : {v_i,v_j} \\in E}. $$ Example: $$ L(v_1) = {(v_2, R_{12}),\\,(v_3, R_{13})}. $$ Adjacency Matrix. Directly input the symmetric matrix \\(A\\) as above: $$ A = \\begin{pmatrix} 0 & R_{12} & \\cdots & R_{1n}\\ R_{21} & 0 & \\cdots & R_{2n}\\ \\vdots & \\vdots & \\ddots & \\vdots\\ R_{n1} & R_{n2} & \\cdots & 0 \\end{pmatrix}. $$ Edge List. A sequence of triples $$ E = {(v_{u_k}, v_{v_k}, r_k)}_{k=1}^m, $$ representing each resistor by its endpoints and resistance. Each format ensures explicit storage of every resistor\u2019s endpoints and resistance value. 3. Assumptions and Constraints Purely Resistive Network. All components obey Ohm\u2019s law: \\( \\(V = IR.\\) \\) Undirected Graph. Symmetry of resistance: $$ w({v_i,v_j}) = w({v_j,v_i}),\\quad \\forall\\,{v_i,v_j}\\in E. $$ Connectivity Between Source and Sink. The graph is connected: $$ \\forall\\,u,v\\in V,\\;\\exists\\;\\text{path }P_{u\\to v}. $$ In particular, the designated source \\(s\\) and sink \\(t\\) must lie in the same connected component. II. Algorithm Design 1. Simplification Strategy Series Reduction. Identify a path \\(P = (v_0, v_1, \\dots, v_k)\\) such that each internal node \\(v_i\\) has degree \\(2\\) , and edges \\(e_i = \\{v_{i-1},v_i\\}\\) with resistances \\(r_i\\) . Replace \\(P\\) by a single edge \\(\\{v_0,v_k\\}\\) with equivalent resistance $$ R_{\\mathrm{series}} = \\sum_{i=1}^k r_i. $$ Parallel Reduction. Identify all edges \\(\\{e_i\\}_{i=1}^p\\) connecting the same node pair \\(\\{u,v\\}\\) with resistances \\(r_i\\) . Replace by a single edge \\(\\{u,v\\}\\) with $$ \\frac{1}{R_{\\mathrm{parallel}}} = \\sum_{i=1}^p \\frac{1}{r_i} \\quad\\Longrightarrow\\quad R_{\\mathrm{parallel}} = \\Bigl(\\sum_{i=1}^p \\tfrac{1}{r_i}\\Bigr)^{-1}. $$ 2. Graph Traversal and Pattern Detection 2.1 Depth-First Search (DFS) Use DFS to explore and flag nodes of degree 2 for series-chain detection. procedure DFS(u): visited[u] \u2190 true for each neighbor v of u do if not visited[v] then DFS(v) end if end for end procedure 2.2 Breadth-First Search (BFS) Use BFS for level-order scans to locate chains iteratively. procedure BFS(s): queue \u2190 [s] visited[s] \u2190 true while queue not empty do u \u2190 dequeue(queue) for each neighbor v of u do if not visited[v] then visited[v] \u2190 true enqueue(queue, v) end if end for end while end procedure 2.3 Parallel-Edge Detection For each node pair \\((u,v)\\) , gather edge set $$ E_{uv} = {e : e\\text{ connects }u\\text{ and }v}. $$ If \\(|E_{uv}| > 1\\) , apply parallel reduction. 3. Termination Condition Iterate series and parallel reductions until the graph reduces to exactly two nodes \\(\\{s,t\\}\\) and a single edge between them. The weight of this final edge is the equivalent resistance: $$ G_{\\mathrm{final}}:\\ V = {s,t},\\ E = {{s,t}},\\ R_{\\mathrm{eq}} = w({s,t}). $$ III. Pseudocode Development 1. High-Level Pseudocode main(): inputData \u2190 readInput() G \u2190 buildGraph(inputData) simplifyGraph(G) R_eq \u2190 computeEquivalentResistance(G) print(\"Equivalent Resistance:\", R_eq) procedure buildGraph(inputData): G \u2190 new Graph() for each (u, v, r) in inputData.edgeList do if not G.containsNode(u) then G.addNode(u) if not G.containsNode(v) then G.addNode(v) G.addEdge(u, v, weight = r) return G procedure simplifyGraph(G): repeat if seriesTriple \u2190 findSeriesTriple(G) then reduceSeries(G, seriesTriple) else if parallelPair \u2190 findParallelPair(G) then reduceParallel(G, parallelPair) else break until false procedure findSeriesTriple(G): for each node v in G.nodes do if v \u2260 s and v \u2260 t and G.degree(v) == 2 then let [u, w] = G.neighbors(v) let r1 = G.edgeWeight(u, v) let r2 = G.edgeWeight(v, w) return (u, v, w, r1, r2) return null procedure reduceSeries(G, (u, v, w, r1, r2)): R_series = r1 + r2 G.removeEdge(u, v) G.removeEdge(v, w) G.removeNode(v) addOrCombineEdge(G, u, w, R_series) procedure findParallelPair(G): for each unordered pair (u, v) in G.nodePairs do edges = G.edgesBetween(u, v) if edges.size > 1 then resistances = [G.edgeWeight(e) for e in edges] return (u, v, resistances) return null procedure reduceParallel(G, (u, v, resistances)): R_parallel = (sum(1/r for r in resistances))\u207b\u00b9 for each e in G.edgesBetween(u, v) do G.removeEdge(e) addOrCombineEdge(G, u, v, R_parallel) procedure addOrCombineEdge(G, u, v, R_new): if G.hasEdge(u, v) then r_old = G.edgeWeight(u, v) R_combined = (1/r_old + 1/R_new)\u207b\u00b9 G.updateEdgeWeight(u, v, R_combined) else G.addEdge(u, v, weight = R_new) procedure computeEquivalentResistance(G): // After simplification, only nodes s and t remain connected by one edge return G.edgeWeight(s, t) VI. Analysis of Algorithm Efficiency 1. Time and Space Complexity Let \\(n = |V|\\) be the number of nodes and \\(m = |E|\\) the number of edges in the circuit graph. Series Reduction Search Each call to findSeriesTriple scans all nodes and inspects degrees and neighbors in \\(O(n + m)\\) . In the worst case, up to \\(n-2\\) series reductions occur (removing one internal node each time). Total cost for series detection and reduction: $$ \\sum_{k=1}^{n-2} O(n_k + m_k) \\;\\approx\\; O\\bigl((n + m)\\,n\\bigr) = O(n^2 + nm). $$ Parallel Reduction Search Each call to findParallelPair may examine each edge or each unordered node\u2010pair. Edge\u2010based approach: grouping edges by endpoint pair can be done in \\(O(m\\log m)\\) (via sorting or hashing). In the worst case, up to \\(m-1\\) parallel reductions occur. Total cost for parallel detection and reduction: $$ \\sum_{k=1}^{m-1} O(m_k \\log m_k) \\;\\approx\\; O(m^2 \\log m). $$ Combined Simplification Loop In each iteration, we attempt a series or parallel reduction. Worst\u2010case iterations \\(\\le n + m\\) . Overall worst\u2010case time complexity: $$ O\\bigl(n^2 + nm + m^2 \\log m\\bigr). $$ Space Complexity Storing the graph with adjacency lists: $$ O(n + m). $$ Auxiliary data (visited flags, degree arrays, hash maps): $$ O(n + m). $$ Total space: $$ O(n + m). $$ Sparse vs. Dense Graphs Sparse ( \\(m = O(n)\\) ): $$ \\text{Time} = O(n^2 + n^2 \\log n) = O(n^2 \\log n). $$ Dense ( \\(m = O(n^2)\\) ): $$ \\text{Time} = O(n^2 + n^3 + n^4 \\log n) = O(n^4 \\log n). $$ In practice, most circuits are sparse, so performance is closer to \\(O(n^2 \\log n)\\) . 2. Bottlenecks Identification Repeated Full-Graph Scans Both series and parallel detection scan the entire graph each iteration. Reducing this by maintaining dynamic candidate lists (e.g., queue of degree-2 nodes or hash buckets of parallel candidates) can lower per-iteration cost to near-constant time. Edge\u2010Grouping for Parallel Reduction Sorting or hashing edges by endpoint pair each time is expensive. A multi-map or adjacency\u2010list extension tracking parallel edges as they form would avoid rebuilding groups. Graph Mutation Overhead Removing and adding nodes/edges in dynamic data structures can incur pointer or array\u2010shifting costs. Using specialized union\u2010find or link\u2010cut trees may accelerate series/parallel merges. Worst\u2010Case Nested Reductions Deeply nested series-parallel combinations may trigger many small reductions. Caching subgraph reduction results (memoization) could prevent redundant work on isomorphic substructures.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#i-problem-understanding-and-modeling","text":"","title":"I. Problem Understanding and Modeling"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-circuit-representation","text":"Definition 1.1 (Weighted Undirected Graph). A circuit is modeled by a weighted undirected graph $$ G = (V, E, w), $$ where - \\(V = \\{v_1, v_2, \\dots, v_n\\}\\) is the set of nodes (junctions); - \\(E \\subseteq \\{\\{v_i, v_j\\} : v_i \\neq v_j\\}\\) is the set of edges (resistors); - \\(w: E \\to \\mathbb{R}^+\\) assigns each edge \\(\\{v_i,v_j\\}\\) a resistance \\(r_{ij} = w(\\{v_i,v_j\\})\\) . Adjacency Matrix \\(A\\) . $$ A_{ij} = \\begin{cases} r_{ij}, & {v_i, v_j} \\in E,\\ 0, & \\text{otherwise}, \\end{cases} \\quad A \\in \\mathbb{R}^{n \\times n},\\ A_{ij}=A_{ji},\\ A_{ii}=0. $$ Degree Matrix \\(D\\) and Laplacian \\(L\\) . Let $$ D = \\mathrm{diag}(d_1,\\dots,d_n), \\quad d_i = \\sum_{j=1}^n A_{ij}. $$ Then the graph Laplacian is $$ L = D - A. $$ Connectivity is equivalent to the algebraic connectivity satisfying $$ \\lambda_2(L) > 0. $$ Incidence Matrix \\(B\\) . For \\(m=|E|\\) , define \\(B\\in\\{-1,0,1\\}^{n\\times m}\\) by arbitrarily orienting each edge \\(e_k=\\{v_i,v_j\\}\\) : $$ B_{ik} = \\begin{cases} 1, & \\text{if } e_k \\text{ is oriented } v_i\\to v_j,\\ -1, & \\text{if } e_k \\text{ is oriented } v_j\\to v_i,\\ 0, & \\text{otherwise}. \\end{cases} $$","title":"1. Circuit Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-input-specification","text":"We adopt one of the following formats: Adjacency List. A function \\(L: V \\to 2^{V\\times\\mathbb{R}^+}\\) where $$ L(v_i) = {(v_j, r_{ij}) : {v_i,v_j} \\in E}. $$ Example: $$ L(v_1) = {(v_2, R_{12}),\\,(v_3, R_{13})}. $$ Adjacency Matrix. Directly input the symmetric matrix \\(A\\) as above: $$ A = \\begin{pmatrix} 0 & R_{12} & \\cdots & R_{1n}\\ R_{21} & 0 & \\cdots & R_{2n}\\ \\vdots & \\vdots & \\ddots & \\vdots\\ R_{n1} & R_{n2} & \\cdots & 0 \\end{pmatrix}. $$ Edge List. A sequence of triples $$ E = {(v_{u_k}, v_{v_k}, r_k)}_{k=1}^m, $$ representing each resistor by its endpoints and resistance. Each format ensures explicit storage of every resistor\u2019s endpoints and resistance value.","title":"2. Input Specification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-assumptions-and-constraints","text":"Purely Resistive Network. All components obey Ohm\u2019s law: \\( \\(V = IR.\\) \\) Undirected Graph. Symmetry of resistance: $$ w({v_i,v_j}) = w({v_j,v_i}),\\quad \\forall\\,{v_i,v_j}\\in E. $$ Connectivity Between Source and Sink. The graph is connected: $$ \\forall\\,u,v\\in V,\\;\\exists\\;\\text{path }P_{u\\to v}. $$ In particular, the designated source \\(s\\) and sink \\(t\\) must lie in the same connected component.","title":"3. Assumptions and Constraints"},{"location":"1%20Physics/5%20Circuits/Problem_1/#ii-algorithm-design","text":"","title":"II. Algorithm Design"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simplification-strategy","text":"Series Reduction. Identify a path \\(P = (v_0, v_1, \\dots, v_k)\\) such that each internal node \\(v_i\\) has degree \\(2\\) , and edges \\(e_i = \\{v_{i-1},v_i\\}\\) with resistances \\(r_i\\) . Replace \\(P\\) by a single edge \\(\\{v_0,v_k\\}\\) with equivalent resistance $$ R_{\\mathrm{series}} = \\sum_{i=1}^k r_i. $$ Parallel Reduction. Identify all edges \\(\\{e_i\\}_{i=1}^p\\) connecting the same node pair \\(\\{u,v\\}\\) with resistances \\(r_i\\) . Replace by a single edge \\(\\{u,v\\}\\) with $$ \\frac{1}{R_{\\mathrm{parallel}}} = \\sum_{i=1}^p \\frac{1}{r_i} \\quad\\Longrightarrow\\quad R_{\\mathrm{parallel}} = \\Bigl(\\sum_{i=1}^p \\tfrac{1}{r_i}\\Bigr)^{-1}. $$","title":"1. Simplification Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-graph-traversal-and-pattern-detection","text":"","title":"2. Graph Traversal and Pattern Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#21-depth-first-search-dfs","text":"Use DFS to explore and flag nodes of degree 2 for series-chain detection. procedure DFS(u): visited[u] \u2190 true for each neighbor v of u do if not visited[v] then DFS(v) end if end for end procedure","title":"2.1 Depth-First Search (DFS)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#22-breadth-first-search-bfs","text":"Use BFS for level-order scans to locate chains iteratively. procedure BFS(s): queue \u2190 [s] visited[s] \u2190 true while queue not empty do u \u2190 dequeue(queue) for each neighbor v of u do if not visited[v] then visited[v] \u2190 true enqueue(queue, v) end if end for end while end procedure","title":"2.2 Breadth-First Search (BFS)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#23-parallel-edge-detection","text":"For each node pair \\((u,v)\\) , gather edge set $$ E_{uv} = {e : e\\text{ connects }u\\text{ and }v}. $$ If \\(|E_{uv}| > 1\\) , apply parallel reduction.","title":"2.3 Parallel-Edge Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-termination-condition","text":"Iterate series and parallel reductions until the graph reduces to exactly two nodes \\(\\{s,t\\}\\) and a single edge between them. The weight of this final edge is the equivalent resistance: $$ G_{\\mathrm{final}}:\\ V = {s,t},\\ E = {{s,t}},\\ R_{\\mathrm{eq}} = w({s,t}). $$","title":"3. Termination Condition"},{"location":"1%20Physics/5%20Circuits/Problem_1/#iii-pseudocode-development","text":"","title":"III. Pseudocode Development"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-high-level-pseudocode","text":"main(): inputData \u2190 readInput() G \u2190 buildGraph(inputData) simplifyGraph(G) R_eq \u2190 computeEquivalentResistance(G) print(\"Equivalent Resistance:\", R_eq) procedure buildGraph(inputData): G \u2190 new Graph() for each (u, v, r) in inputData.edgeList do if not G.containsNode(u) then G.addNode(u) if not G.containsNode(v) then G.addNode(v) G.addEdge(u, v, weight = r) return G procedure simplifyGraph(G): repeat if seriesTriple \u2190 findSeriesTriple(G) then reduceSeries(G, seriesTriple) else if parallelPair \u2190 findParallelPair(G) then reduceParallel(G, parallelPair) else break until false procedure findSeriesTriple(G): for each node v in G.nodes do if v \u2260 s and v \u2260 t and G.degree(v) == 2 then let [u, w] = G.neighbors(v) let r1 = G.edgeWeight(u, v) let r2 = G.edgeWeight(v, w) return (u, v, w, r1, r2) return null procedure reduceSeries(G, (u, v, w, r1, r2)): R_series = r1 + r2 G.removeEdge(u, v) G.removeEdge(v, w) G.removeNode(v) addOrCombineEdge(G, u, w, R_series) procedure findParallelPair(G): for each unordered pair (u, v) in G.nodePairs do edges = G.edgesBetween(u, v) if edges.size > 1 then resistances = [G.edgeWeight(e) for e in edges] return (u, v, resistances) return null procedure reduceParallel(G, (u, v, resistances)): R_parallel = (sum(1/r for r in resistances))\u207b\u00b9 for each e in G.edgesBetween(u, v) do G.removeEdge(e) addOrCombineEdge(G, u, v, R_parallel) procedure addOrCombineEdge(G, u, v, R_new): if G.hasEdge(u, v) then r_old = G.edgeWeight(u, v) R_combined = (1/r_old + 1/R_new)\u207b\u00b9 G.updateEdgeWeight(u, v, R_combined) else G.addEdge(u, v, weight = R_new) procedure computeEquivalentResistance(G): // After simplification, only nodes s and t remain connected by one edge return G.edgeWeight(s, t)","title":"1. High-Level Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#vi-analysis-of-algorithm-efficiency","text":"","title":"VI. Analysis of Algorithm Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-time-and-space-complexity","text":"Let \\(n = |V|\\) be the number of nodes and \\(m = |E|\\) the number of edges in the circuit graph. Series Reduction Search Each call to findSeriesTriple scans all nodes and inspects degrees and neighbors in \\(O(n + m)\\) . In the worst case, up to \\(n-2\\) series reductions occur (removing one internal node each time). Total cost for series detection and reduction: $$ \\sum_{k=1}^{n-2} O(n_k + m_k) \\;\\approx\\; O\\bigl((n + m)\\,n\\bigr) = O(n^2 + nm). $$ Parallel Reduction Search Each call to findParallelPair may examine each edge or each unordered node\u2010pair. Edge\u2010based approach: grouping edges by endpoint pair can be done in \\(O(m\\log m)\\) (via sorting or hashing). In the worst case, up to \\(m-1\\) parallel reductions occur. Total cost for parallel detection and reduction: $$ \\sum_{k=1}^{m-1} O(m_k \\log m_k) \\;\\approx\\; O(m^2 \\log m). $$ Combined Simplification Loop In each iteration, we attempt a series or parallel reduction. Worst\u2010case iterations \\(\\le n + m\\) . Overall worst\u2010case time complexity: $$ O\\bigl(n^2 + nm + m^2 \\log m\\bigr). $$ Space Complexity Storing the graph with adjacency lists: $$ O(n + m). $$ Auxiliary data (visited flags, degree arrays, hash maps): $$ O(n + m). $$ Total space: $$ O(n + m). $$ Sparse vs. Dense Graphs Sparse ( \\(m = O(n)\\) ): $$ \\text{Time} = O(n^2 + n^2 \\log n) = O(n^2 \\log n). $$ Dense ( \\(m = O(n^2)\\) ): $$ \\text{Time} = O(n^2 + n^3 + n^4 \\log n) = O(n^4 \\log n). $$ In practice, most circuits are sparse, so performance is closer to \\(O(n^2 \\log n)\\) .","title":"1. Time and Space Complexity"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-bottlenecks-identification","text":"Repeated Full-Graph Scans Both series and parallel detection scan the entire graph each iteration. Reducing this by maintaining dynamic candidate lists (e.g., queue of degree-2 nodes or hash buckets of parallel candidates) can lower per-iteration cost to near-constant time. Edge\u2010Grouping for Parallel Reduction Sorting or hashing edges by endpoint pair each time is expensive. A multi-map or adjacency\u2010list extension tracking parallel edges as they form would avoid rebuilding groups. Graph Mutation Overhead Removing and adding nodes/edges in dynamic data structures can incur pointer or array\u2010shifting costs. Using specialized union\u2010find or link\u2010cut trees may accelerate series/parallel merges. Worst\u2010Case Nested Reductions Deeply nested series-parallel combinations may trigger many small reductions. Caching subgraph reduction results (memoization) could prevent redundant work on isomorphic substructures.","title":"2. Bottlenecks Identification"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}